# 이펙티브 타입스크립트
### 지은이 : 댄 밴더캄
### 옮긴이 : 장원호
### 출판사 : 인사이트
### 읽은 날 : 2021.12.30 ~ 2022.01.16

1. 타입 시스템의 목표 중 하나는 런타임에 오류를 발생시킬 코드를 미리 찾아내는 것입니다. 타입스크립트가 '정적' 타입 시스템이라는 것은 바로 이런 특징을 말하는 것입니다. 그러나 타입 체커가 모든 오류를 찾아내지는 않습니다.

2. 타입스크립트는 타입 정보를 가질 때 가장 효과적이기 때문에, 되도록이면 noImplicitAny를 설정해야 합니다. 모든 변수에 타입을 명시하는 것에 익숙해지면, noImplicitAny가 없는 채로 작성된 타입스크립트는 완전히 다른 언어처럼 느껴질 겁니다.

3. strictNullChecks는 null과 undefined 관련된 오류를 잡아 내는 데 많은 도움이 되지만, 코드 작성을 어렵게 합니다. 새 프로젝트를 시작한다면 가급적 strictNullChecks를 설정하는 것이 좋지만, 타입스크립트가 처음이거나 자바스크립트 코드를 마이그레이션 하는 중이라면 설정하지 않아도 괜찮습니다. strictNullChecks를 설정하려면 noImplicitAny를 먼저 설정해야 합니다.

4. strictNullChecks 설정 없이 개발하기로 선택했다면, "undefined는 객체가 아닙니다"라는 끔찍한 런타임 오류를 주의하기 바랍니다. 결국은 이 오류 때문에 엄격한 체크를 설정할 수밖에 없을 겁니다. 프로젝트가 거대해질수록 설정 변경은 어려워질 것이므로, 가능한 한 초반에 설정하는 게 좋습니다.

5. 인터페이스는 타입으로만 사용 가능하지만, Rectangle을 클래스로 선언하면 타입과 값으로 모두 사용할 수 있으므로 오류가 없습니다.

6. 타입스크립트에서는 런타임 타입과 선언된 타입이 맞지 않을 수 있습니다. 타입이 달라지는 혼란스러운 상황을 가능한 한 피해야 합니다. 선언된 타입이 언제든지 달라질 수 있다는 것을 명심해야 합니다.

7. '런타임' 오버헤드가 없는 대신, 타입스크립트 컴파일러는 '빌드타임' 오버헤드가 있습니다.

8. 정확한 타입으로 객체를 순회하는 것은 까다로운 문제입니다.

9. extends 키워드는 제너릭 타입에서 한정자로도 쓰이며, 이 문맥에서는 '~의 부분집합'을 의미하기도 합니다.

10. 타입의 관점에서, typeof는 값을 읽어서 타입스크립트 타입을 반환합니다. 타입 공간의 typeof는 보다 큰 타입의 일부분으로 사용할 수 있고, type 구문으로 이름을 붙이는 용도로도 사용할 수 있습니다.

11. 값의 관점에서 typeof는 자바스크립트 런타임의 typeof 연산자가 됩니다.

12. 타입 단언은 타입 체커가 추론한 타입보다 여러분이 판단하는 타입이 더 정확할 때 의미가 있습니다. 예를 들어, DOM 엘리먼트에 대해서는 타입스크립트보다 여러분이 더 정확히 알고 있을 겁니다.

13. 접미사로 쓰인!는 그 값이 null이 아니라는 단언문으로 해석됩니다.

14. 타입 중복은 코드 중복만큼 많은 문제를 발생시킵니다.

15. 타입을 반복하는 대신 제너릭 타입을 사용하여 타입들 간에 매핑을 하는 것이 좋습니다. 제너릭 타입을 제한하려면 extends를 사용하면 됩니다.

16. 표준 라이브러리에 정의된 Pick, Partial, ReturnType 같은 제너릭 타입에 익숙해져야 합니다.

17. 인덱스 시그니처는 부정확하므로 더 나은 방법을 찾아야 합니다.

18. 가능하다면 인터페이스, Record, 매핑된 타입 같은 인덱스 시그니처보다 정확한 타입을 사용하는 것이 좋습니다.

19. 타입스크립트는 이러한 혼란을 바로잡기 위해 숫자 키를 허용하고, 문자열 키와 다른 것으로 인식합니다. Array에 대한 타입 선언은 lib.es5.d.ts에서 확인할 수 있습니다.

20. 값에 추가로 타입을 작성하는 것은 거추장스러울 뿐입니다. (객체 리터럴 타입추론)

21. 린터를 사용하고 있다면 eslint 규칙 중 no-inferrable-types을 사용해서 작성된 모든 타입 구문이 정말로 필요한지 확인할 수 있습니다.

22. tagged union (discriminated union)

23. const는 단지 값이 가리키는 참조가 변하지 않는 얕은(shallow) 상수인 반면, as const는 그 값이 내부까지(deeply) 상수라는 사실을 타입스크립트에게 알려 줍니다.

24. as const는 문맥 손실과 관련한 문제를 깔금하게 해결할 수 있지만, 한 가지 단점을 가지고 있습니다. 만약 타입 정의에 실수가 있다면(예를 들어, 튜플에 세 번째 요소를 추가한다면) 오류는 타입 정의가 아니라 호출되는 곳에서 발생한다는 것이빈다. 특히 여러 겹 중첩된 객체에서 오류가 발생한다면 근본적인 원인을 파악하기 어렵습니다.

25. 그러나 같은 코드를 타입스크립트로 작성하면 서드파티 라이브러리를 사용하는 것이 무조건 유리합니다.

26. 누군가 강제하지 않는 이상 주석은 코드와 동기화되지 않습니다.

27. 주석과 변수명에 타입 정보를 적는 것은 피해야 합니다. 타입 선언이 중복되는 것으로 끝나면 다행이지만 최악의 경우는 타입 정보에 모순이 발생하게 됩니다.

28. undefined를 포함하는 객체는 다루기 어렵고 절대 권장하지 않습니다.

29. string은 any와 비슷한 문제를 가지고 있습니다. 따라서 잘못 사용하게 되면 무효한 값을 허용하고 타입 간의 관계도 감추어 버립니다.
