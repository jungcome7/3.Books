# 코어 자바스크립트
### 지은이 : 정재남
### 출판사 : 위키북스
### 읽은 날 : 2020.08.08

### 1. 데이터 타입
### 2. 실행 컨텍스트
### 3. this
### 4. 콜백 함수
### 5. 클로저
### 6. 프로토타입
### 7. 클래스

### 1. 데이터 타입
1. C/C++, 자바 등의 정적 타입 언어는 메모리의 낭비를 최소화하기 위해 데이터 타입별로 할당할 메모리 영역을 2바이트, 4바이트 등으로 나누어 정해놓았습니다.

2. 숫자의 경우 정수형인지 부동소수형인지를 구분하지 않고 64비트, 즉 8바이트를 확보합니다. 덕분에 개발자가 위와 같은 형변환을 걱정해야 하는 상황이 훨씬 덜 발생하게 됐습니다.

3. 이 결과가 바로 기본형과 참조형 데이터의 가장 큰 차이점입니다. 대부분의 자바스크립트 책에서 '기본형은 값을 복사하고 참조형은 주솟값을 복사한다'고 설명하고 있지만, 사실은 어떤 데이터 타입이든 변수에 할당하기 위해서는 주솟값을 복사해야 하기 때문에, 엄밀히 따지면 자바스크립트의 모든 데이터 타입은 참조형 데이터일 수밖에 없습니다. 다만 기본형은 주솟값을 복사하는 과정이 한 번만 이뤄지고, 참조형은 한 단계를 더 거치게 된다는 차이가 있는 것입니다.

4. 일반적으로는 '기본형도 결국 주솟값을 참조한다'는 사실을 소개하지 않는데, 그 이유는 이해하기에 다소 어려움이 있기 때문이라고 추측합니다. 그러나 이런 내부 원리를 잘 이해하는 것은 향후 중급 개발자로 성장하는 과정에서 더 큰 혼란을 느끼지 않기 위한 중요한 초석이 될 것이라고 믿습니다.

5. 추가로 hasOwnProperty 메서드를 활용해 프로토타입 체이닝을 통해 상속된 프로퍼티를 복사하지 않게끔 할 수도 있습니다.

6. 끝으로 간단하게 깊은 복사를 처리할 수 있는 다른 방법 하나를 더 소개하겠습니다. 원리도 단순합니다. 객체를 JSON 문법으로 표현된 문자열로 전환했다가 다시 JSON 객체로 바꾸는 겁니다. 이 방법은 단순함에도 불구하고 잘 동작합니다. 다만 메서드(함수)나 숨겨진 프로퍼티인 __proto__나 getter/setter 등과 같이 JSON으로 변경할 수 없는 프로퍼티들은 모두 무시합니다. httpRequest로 받은 데이터를 저장한 객체를 복사할 때 등 순수한 정보만 다룰 때 활용하기 좋은 방법입니다.

7. 이처럼 '비어있는 요소'와 'undefined를 할당한 요소'는 출력 결과부터 다릅니다. '비어있는 요소'는 순회와 관련된 많은 배열 메서드들의 순회 대상에서 제외됩니다.

8. 배열은 무조건 length 프로퍼티의 개수만큼 빈 공간을 확보하고 각 공간에 인덱스를 이름으로 지정할 것이라고 생각하기 쉽지만, 실제로는 객체와 마찬가지로 특정 인덱스에 값을 지정할 때 비로소 빈 공간을 확보하고 인덱스를 이름으로 지정하고 데이터의 주솟값을 저장하는 등의 동작을 합니다.

9. 값으로써 어딘가에 할당된 undefined는 실존하는 데이터인 반면, 자바스크립트 엔진이 반환해주는 undefined는 문자 그대로 값이 없음을 나타내는 것입니다.

### 2. 실행 컨텍스트
### 3. this
10. 자바스크립트에서 this는 기본적으로 실행 컨텍스트가 생성될 때 함께 결정됩니다. 실행 컨텍스트는 함수를 호출할 때 생성되므로, 바꿔 말하면 this는 함수를 호출할 때 결정된다고 할 수 있겠습니다.

11. 자바스크립트의 모든 변수는 실은 특정 객체의 프로퍼티로서 동작하기 때문입니다.

12. 자바스크립트를 처음 접하는 분들은 흔히 메서드를 '객체의 프로퍼티에 할당된 함수'로 이해하곤 합니다. 반은 맞고 반은 틀립니다. 어떤 함수를 객체의 프로퍼티에 할당한다고 해서 그 자체로서 무조건 메서드가 되는 것이 아니라 객체의 메서드로서 호출할 경우에만 메서드로 동작하고, 그렇지 않으면 함수로 동작합니다.

13. 이 함수는 호출할 때 함수명인 outer 앞에 점(.)이 있었으므로 메서드로서 호출한 것입니다.

14. 이 함수를 호출할 때 함수명 앞에는 점(.)이 없었습니다. 즉 함수로서 호출한 것이므로 this가 지정되지 않았고, 따라서 자동으로 스코프 체인상의 최상위 객체인 전역객체(Window)가 바인딩됩니다.

15. 그러니까 this 바인딩에 관해서는 함수를 실행하는 당시의 주변 환경(메서드 내부인지, 함수 내부인지 등)은 중요하지 않고, 오직 해당 함수를 호출하는 구문 앞에 점 또는 대괄호 표기가 있는지 없는지가 관건인 것입니다.

16. ES6에서는 함수 내부에서 this가 전역객체를 바라보는 문제를 보완하고자, this를 바인딩하지 않는 화살표 함수를 새로 도입했습니다. 화살표 함수는 실행 컨텍스트를 생성할 때 this 바인딩 과정 자체가 빠지게 되어, 상위 스코프의 this를 그대로 활용할 수 있습니다.

17. addEventListener 메서드는 콜백 함수를 호출할 때 자신의 this를 상속하도록 정의돼 있습니다. 그러니까 메서드명의 점(.) 앞부분이 곧 this가 되는 것이죠.

18. bind 메서드는 ES5에서 추가된 기능으로, call과 비슷하지만 즉시 호출하지는 않고 넘겨받은 this 및 인수들을 바탕으로 새로운 함수를 반환하기만 하는 메서드입니다.

19. 즉 bind 메서드는 함수에 this를 미리 적용하는 것과 부분 적용 함수를 구현하는 두 가지 목적을 모두 지닙니다.


### 4. 콜백 함수
20. 콜백 함수는 제어권과 관련이 깊습니다.

21. 이처럼 콜백 함수는 다른 코드(함수 또는 메서드)에게 인자로 넘겨줌으로써 그 제어권도 함께 위임한 함수입니다.

22. 콜백 함수는 함수입니다. 당연한 소리라 생각할 수 있지만 이 의미를 곰곰이 생각해볼 필요가 있습니다. 콜백 함수로 어떤 객체의 메서드를 전달하더라도 그 메서드는 메서드가 아닌 함수로서 호출됩니다.

### 5. 클로저
### 6. 프로토타입
### 7. 클래스
23. 자바스크립트에서 클래스 상속을 구현했다는 것은 결국 프로토타입 체이닝을 잘 연결한 것으로 이해하면 되는 것입니다.
