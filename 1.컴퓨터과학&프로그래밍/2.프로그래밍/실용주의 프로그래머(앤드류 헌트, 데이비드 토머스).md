# 실용주의 프로그래머(The Pragmatic Programmer)
### 지은이 : 앤드류 헌트(Andrew Hunt), 데이비드 토머스(David Thomas)
### 옮긴이 : 김창준, 정지호
### 출판사 : 인사이트
### 읽은 날 : 2020.06.24

1. 바로 이것이 실용주의가 뜻하는 바다. 어떤 특정 기술에 매이면 안 되며, 개별 상황마다 그 상황에서 좋은 해결방안을 고를 수 있도록 충분한 배경지식과 경험을 가져야 한다. 배경지식은 컴퓨터 과학의 기본 원리들을 이해하는 것에서 나오고, 경험은 다양한 범위의 실제 프로젝트들을 수행해보는 것에서 나온다. 이론과 실천의 결합이 여러분을 강하게 만든다.

2. '깨진 창문' (나쁜 설계, 잘못된 결정, 혹은 형편없는 코드)을 고치지 않은 채로 내버려 두지 마라. 발견하자마자 바로 고쳐라. 적절히 고칠 시간이 충분치 않다면 판자로 덮는 것만이라도 하라. 불쾌한 코드를 주석처리 하거나, '아직 구현되지 않았음Not Implemented'이라는 메시지를 표시하거나, 가짜dummy 데이터로 대치해 놓거나 하라. 더 이상의 손상을 예방하기 위해 어떤 조치든 취하고 현 상황을 잘 관리하고 있다는 것을 보여 줘라.

3. 무엇을 해야 하는지, 어떻게 해야 하는지 정확히 아는 상황이 있다. 전체 시스템이 눈앞에 그냥 드러난다. 여러분은 그 시스템이 옳다는 걸 안다. 하지만 일을 착수하려고 허락을 구하는 때부터, 뭔가가 지연되거나 사람들이 멍한 눈으로 여러분을 바라본다. 위원회가 생길 테고, 예산 승인이 필요하고, 일들이 복잡해지기 시작한다. 모든 사람이 각자 자신의 자원을 지키려고 할 것이다. 때때로 이걸 '시작 피로start-up fatigue'라고 부른다.

4. 지식에 대한 투자가 언제나 최고의 이윤을 낸다. -벤자민 프랭클린(Benjamin Franklin)

5. 
- 매년 새로운 언어를 최소 하나는 배워라.
- 기술 서적을 분기마다 한 권씩 읽어라.  
 : 습관이 들면, 한 달에 한 권씩 읽어라.
- 비 기술 서적도 읽어라.  
 : 컴퓨터를 사용하는 것은 사람 - 우리는 바로 이 사람들을 만족시키려고 노력하고 있다 - 이라는 점을 기억하는 게 중요하다. 방정식에서 인간이라는 변을 잊지 마라.
- 수업을 들어라.
- 지역 사용자 모임에 참여하라.  
 : 가서 가만히 듣고만 오지 말고, 적극 참여하라. 고립은 경력에 치명적일 수 있다.
- 다른 환경에서 실험해보라.  
 : 윈도우에서만 일을 해 왔다면, 집에서는 유닉스를 갖고 놀아보라.
- 요즘 흐름을 놓치지 마라.

6. 프로그래머들은 늘 유지보수 모드에 있다. 우리가 이해하고 있는 것은 날마다 바뀐다. 설계를 하거나 코딩을 하는 중에 새로운 요구사항이 도착한다. 어쩌면 환경이 변할 수도 있다. 이유가 무엇이건 간에, 유지보수는 별개의 활동이 아니며, 전체 개발 과정의 일상적인 부분이다.

7. 직교성(Orthogonality)이란?  
컴퓨팅에서 이 용어는 일종의 독립성(independence)이나, 결합도 줄이기(decoupling)를 의미한다. 하나가 바뀌어도 나머지에 어떤 영향도 주지 않으면 서로 직교한다고 할 수 있다. 잘 설계된 시스템에서는 데이터베이스 코드가 사용자 인터페이스에 대해 직교할 것이다. 데이터베이스에 영향을 주지 않으면서 인터페이스를 바꿀 수 있고, 또한 인터페이스를 바꾸지 않으면서 데이터베이스를 교환할 수 있다.

8. 버그 수정은 시스템의 직교성을 총체적으로 점검해 볼 수 있는 값진 시간이다. 문제가 발생했다면 버그 수정이 얼마나 지역화 되어 있는지 평가해 보라.

9. 프로토타입에서 기대하는 것은 전체적으로 시스템이 어떻게 동작할지에 대한 감을 잡는 것이다. 다시 말하지만 세부사항은 무시한다.

10. 프로토타입을 적절히 사용하면 많은 시간과 돈, 고통과 고생을 줄일 수 있다. 이는 실수를 저렴하면서 동시에 쉽게 고칠 수 있는 개발주기 초기에, 잠재적 문제 지점을 발견하고 또 고칠 수 있기 때문이다.

11. 마우스로 포인팅하고 클릭함으로써 결국 모든 걸 똑같이 잘 할 수 있는 것 아닌가?  
간단한 대답은 '아니오'다. GUI 인터페이스는 훌륭한 것이고, 몇 가지 간단한 조작에는 그게 더 빠르고 편리할 수도 있다. 파일을 이동하고, MIME 형식으로 인코딩된 이메일을 읽고, 글자를 쳐 넣고 하는 것들은 모두 그래픽 환경에서 하는 게 좋을 수 있다. 하지만 모든 작업을 GUI로만 한다면, 여러분이 가진 환경의 전체 능력을 이용하지 못하게 된다. 일반적인 작업을 자동화할 수 없고, 쓸 수 있는 도구의 풀파워를 사용할 수 없다. 게다가 도구를 결합해서 자신에게 꼭 맞는 매크로 도구를 만들 수가 없다.

12. GUI의 장점은 WYSIWYG(What You See Is What You Get), 즉 여러분이 보는 것이 여러분이 얻는 것이라는 것이다. 단점은 WYSIAYG(What You See Is All You Get), 즉 여러분이 보는 것이 여러분이 얻는 전부라는 것이다.

13. 가장 속이기 쉬운 사람은 자기 자신이다. - 에드워드 불워-리톤(Edward Bulwer-Lytton), 'The Disowned'

14. 디버깅을 할 때 근시를 조심하라. 표면에 보이는 증상만 고치려는 욕구에 저항하라. 실제 문제는 여러분이 관찰하고 있는 것에서 몇 단계 떨어져 있고, 또 다른 여러 가지와 연관되어 있을 확률이 다분하다. 항상 문제의 근본적인 원인을 발견하려고 노력하고, 그 문제의 특정한 증상만 고치려고 하지 말라.

15. 좋은 울타리는 좋은 이웃을 만든다. -로버트 프로스트(Robert Frost), '담장 고치기(Mending Wall)'

16. 76쪽 '직교성'과 184쪽 '계약에 의한 설계'에서는 '부끄럼 타는(shy)' 코드를 작성하는 것이 이롭다고 설명했다. 이때 '부끄럼 타는'이란 자신을 남에게 속속들이 드러내지 말고, 너무 많은 사람과 상호작용하지 말라는 두 가지 의미를 모두 내포한다.

17. 메타데이터란 정확히 뭘까? 엄밀히 말해서 메타데이터는 데이터에 관한 데이터다. 데이터베이스 스키마, 데이터 디렉터리 등을 대표적인 예로 들 수 있다. 스키마는 이름, 저장 길이, 그리고 이외의 몇몇 속성을 이용하여 필드(컬럼)를 기술하는 데이터를 포함한다. 여러분은 이 정보를 데이터베이스의 다른 정보와 같이 접근하고 조작할 수 있을 것이다.

18. 하지만 우리는 메타데이터를 좀 더 넓은 의미로 사용한다. 메타데이터는 애플리케이션을 기술하는 모든 데이터다. 애플리케이션이 어떻게 실행되어야 하고, 어떤 자원을 이용해야 하는지 등을 기술한다면 메타데이터라 할 수 있다. 보통 메타데이터는 컴파일타임이 아닌 런타임에 접근, 사용된다. 여러분이 컴퓨터를 사용한다면 이미 메타데이터를 사용하는 셈이다. 웹 브라우저에서 툴바를 감추는 옵션을 선택했다고 가정해 보자. 브라우저는 사용자의 선호사항(preference)을 일종의 내부 데이터베이스에 저장할 것이다.

19. 여전히, 사람은 듣네  
자기가 듣고 싶은 것만  
나머지는 무시한다네  
라 라 라...
-사이먼 앤 가펑클(Simon and Garfunkel), 'The Boxer'

20. 우리는 전부터 프로그램을 커다란 덩어리 하나로 짜지 말고, '나눠서 정복하기(divide and conquer)' 방법을 써서 여러 모듈로 나누어 짜야 한다고 배웠다. 모듈마다 자기만의 책임이 있다. 사실, '잘 정의된 단 하나의 책임만 가지는 것'이라는 말이야말로 모듈(또는 클래스)에 대한 좋은 정의가 된다.

21. 모델-뷰-컨트롤러  
스프레드시트 애플리케이션이 있다고 해보자. 스프레드시트 안에는 숫자들 말고도, 그 숫자들을 막대그래프로 나타내는 그래프와 스프레드시트 한 열에 있는 숫자들의 합을 보여주는 합계 대화상자도 있다.  
분명히, 데이터를 세 곳에 중복해 두고 싶지는 않다. 그러므로 우리는 모델, 곧 데이터 자체와 그 데이터를 조작하는 공통 연산들을 만든다. 그런 다음이라면 스프레드시트, 그래프, 합계 상자 등 다른 방식으로 데이터를 보여주는 여러 독립된 뷰들을 만들 수 있다. 뷰마다 자신만의 컨트롤러를 가지기도 한다. 예를 들어 그래프 뷰는 확대, 축소를 하거나 데이터를 돌려보게 해주는 컨트롤러를 가질 수 있다. 이런 것들은 데이터 자체에는 아무 영향을 미치지 않고 오직 뷰에만 영향을 미친다.  
모델을 표시하는 뷰 그리고 뷰를 관리하는 컨트롤러에서 모델을 분리해 내는 것. 바로 이것이 모델-뷰-컨트롤러(Model-View-Controller, MVC) 이디엄(idiom)의 핵심 개념이다.

22. MVC는 보통 GUI 개발이라는 맥락에서 가르치지만 사실 일반적으로도 쓸 수 있는 프로그래밍 기법이다. 뷰는 모델(아마도 모델의 일부)을 해석하는 방식이다. 꼭 그래픽과 관련될 필요가 없다. 컨트롤러는 조정 작용을 하는 메커니즘이라고 봐야 하며, 어떤 입력 장치와 꼭 연결시켜 생각하지 않아도 도니다.

- 모델 : 대상 객체를 나타내는 추상 데이터 모델. 모델은 어떤 뷰나 컨트롤러에 대해서도 직접적인 지식을 지니지 않는다.
- 뷰 : 모델을 해석하는 방법. 뷰는 모델의 변화 그리고 컨트롤러가 보내는 논리적 사건을 구독한다.
- 컨트롤러 : 뷰를 제어하고 모델에 새로운 데이터를 제공하는 방법. 모델과 뷰 둘 모두에 이벤트를 보낸다.

23. 일단 코딩에 들어가면 대부분 기계적으로 따라가야 하는 일, 곧 설계 내용을 컴퓨터가 실행할 수 있는 문장으로 바꾸는 일만 남는다는 생각이 일반적이다. 이런 태도가 우리 생각에는 보기 흉하고, 비효율적이고, 구조가 엉망이고, 유지보수하기 힘들고, 한마디로 완전히 잘못된 프로그램이 그렇게나 많게 된 가장 큰 원인이다.

24. 코딩은 기계적인 작업이 아니다. 만약 그랬다면, 1980년대 초반에 수많은 사람들이 기대를 걸었던 CASE 도구들이 이미 오래 전에 프로그래머를 대체했을 것이다. 코딩할 때는 매분마다 결정을 내려야 하는데, 프로그램이 정확하고 생산적으로 작동하면서 천수를 누리도록 하기 위해서는 사려 깊은 생각과 판단을 통한 결정이 필요하다.

25. 적극적으로 자기 코드에 대해 생각하지 않는 프로그래머는 우연에 맡기는 프로그래밍(programming by coincidence)을 하는 것이다.

26. 왜 코드가 잘 돌아가지 않게 되었는지 프레드가 모르는 까닭은, 코드가 처음부터 왜 잘 돌아가는지도 몰랐기 때문이다.

27. 맹목적으로 코딩하지 말라. 완전하게 이해하지 못한 애플리케이션을 빌드하려 하거나 익숙하지 않은 기술을 사용하려고 시도하는 행동은 우연에게 자기를 미혹해도 좋다는 초청장을 보내는 것과 다름없다.

28. 불행하게도, 소프트웨어 개발을 비유하는 가장 흔한 메타포는 건물의 건축이다. 버트란트 마이어(Bertrand Meyer)는 '소프트웨어 건축(Software Construction)'이라는 표현을 사용한다. 하지만, 건축을 생각을 이끄는 메타포로 사용한다면 다음 세 가지를 전제하게 된다.

- 설계자(architect)가 설계도를 그린다.
- 건축업자는 땅의 기반을 다지고, 상부구조를 세우고, 전선과 배관을 잇고, 최종 마무리를 한다.
- 입주자가 건물 안에 이사 와서 행복하게 산다. 문제가 생기면 건물 관리소에 연락해서 고친다.

하지만 소프트웨어는 이런식으로 돌아가지 않는다. 소프트웨어는 건축보다 오히려 정원일(gardening)에 더 가깝다. 딱딱하기보다는 유기적인 존재다. 정원에는 초기 계획과 조건에 따라서 여러 가지 식물을 심는다. 몇몇은 잘 자라고, 몇몇은 퇴비가 될 운명이다. 빛과 그림자, 바람과 비의 상호작용을 더 잘 이용하기 위해 식물들의 상대적인 위치를 옮기기도 한다. 너무 많이 자란 식물은 포기를 나누거나 가지치기를 한다. 식물의 색이 서로 충돌하면 더 아름답게 보이도록 위치를 바꾸기도 한다. 잡초를 뽑고, 특별히 더 돌볼 필요가 있는 식물에게는 비료를 주기도 한다. 정원의 건강 상태를 지속적으로 관찰하며, 필요하면 토양, 식물, 정원 배치를 조정하기도 한다.

29. 사업가들은 건물 건축이라는 메타포를 더 편안하게 여긴다. 정원일보다 더 과학적이며, 반복가능하고, 관리를 위한 엄격한 보고 위계질서도 있고 등등 때문이다. 하지만 우리가 하는 일은 마천루를 세우는 작업과는 다르다. 우리는 물리학과 현실 세계의 제약에서 자유롭다.

30. 소프트웨어 개발의 현실에는 정원일 메타포가 훨씬 더 가깝다. 어떤 루틴이 너무 크게 자라거나 너무 낳은 것을 하려고 할지도 모른다. 그러면 둘로 나눠야 한다. 계획한 대로 잘 되지 않는 것들은 잡초 제거를 하거나 가지치기를 해주어야 한다.

31. 리팩터링해야 할 것들의 명단을 만들고 유지하라. 어떤 것을 지금 당장 리팩터링하기 힘들다면, 일정에 그것을 리팩터링할 시간을 확실히 포함시켜 두도록 한다. 그 코드를 사용하는 사람들이 코드가 조만간 리팩터링될 것이라는 사실과 그 사실이 그들의 코드에 어떤 영향을 주게 될지 인지하도록 만들어야 한다.

32. 여러분이 작성하는 모든 소프트웨어는 언젠가는 테스트된다. 여러분이나 여러분 팀이 테스트하지 않으면, 결과적으로 사용자들이 테스트하게 된다. 따라서 소프트웨어를 철저하게 테스트할 계획을 세우는 것이 좋다. 약간의 선견지명으로 유지보수 비용과 고객 지원실에 걸려오는 전화 횟수를 줄이는데 장족의 발전을 이룰 수 있다.

33. 테스트는 기술적이라기보다는 문화적인 것이다.

34. 사용자처럼 생각하기 위해 사용자와 함께 일하라.

35. 요구사항 문서화  
이제 여러분은 사용자와 함께 앉아서 그들의 진정한 요구사항을 캐기 시작한다. 그 애플리케이션이 해야 할 것을 묘사하는 몇 가지 그럴싸한 시나리오를 얻게 된다. 전문가라면 이것들으 기록해서 다른 사람들(개발자, 최종 사용자, 프로젝트 후원자)이 토론을 할 때 기초자료로 사용할 수 있도록 문서화하려 할 것이다.

36. 그 문서의 독자층은 정말로 폭이 넓다.  
이바 야콥슨(Ivar Jacobson)은 요구사항을 갈무리하는 유스 케이스(use case)의 개념을 제안했다. 유스 케이스는 시스템의 특정한 사용(use)을 설명한다. 사용자 인터페이스의 차원에서가 아니고, 좀 더 추상적인 차원에서의 얘기다.

37. 
- 더 쉬운 방법이 존재하는가?
- 진짜 문제를 풀려고 노력하고 있나. 그렇지 않다면 중요하지 않은 기술적 문제에 정신이 팔려 있는 것인가?
- 왜 이것이 문제인가?
- 문제를 이렇게 풀기 어렵게 만드는 것이 무엇인가?
- 반드시 이 방법으로 해야 하는가?
- 반드시 해야 하는 일이긴 한가?

38. 고르디우스의 매듭처럼, 요구사항을 새롭게 해석하니 문제 전체가 사라져 버리는 경우도 많다.

39. 우리에게 필요한 것은 진짜 제약과 우리를 오도하는 제약 그리고 그 차이를 구별하기 위한 지혜다.

40. 어떤 일을 뛰어나게 수행하는 사람들은 공통점이 하나 있다. 그들은 언제 시작해야 하고 언제 기다려야 하는지 안다.

41. 오해의 여지가 있을까봐 하는 말인데, 우리는 명세서를 만드는 일에 반대하는 것이 아니다. 사실, 계약상의 이유나, 여러분이 일하는 환경 때문에, 또는 여러분이 개발하는 제품의 성격 때문에 믿을 수 없을 정도로 상세한 명세서가 필요한 경우도 있다. 단지 명세서가 계속 상세해지다 보면 결국 그 이득이 감소하거나 심지어 줄어드는 지점에 이르게 된다는 점을 염두에 두어야 한다. 그리고 어떤 명세서를 뒷받침 해주는 구현이나 프로토타입 없이 그 명세서를 기반으로 그 위에 또 다른 명세서를 만드는 것도 조심해야 한다. 만들어질 수는 없어도 그 명세를 쓰는 일은 너무나도 쉽기 때문이다.

42. 우리가 형식적 방법을 사용해야 할까?  
물론이다. 하지만 형식적 방법은 단지 도구 상자 속의 또 다른 도구일 뿐이라는 사실을 늘 기억하라. 만약, 주의 깊게 분석한 후에 어떤 형식적 방법을 사용할 필요가 있다고 생각한다면, 기꺼이 그렇게 하라. 하지만 누가 주인인지 분명히 기억해라. 절대로 방법론의 노예가 되지 말라.

43. 실용주의 프로그래머들은 방법론을 비판적인 시각으로 바라본 다음, 각각의 방법론에서 가장 좋은 것만 뽑아 매달 점점 좋아지는 자시느이 작업 실천방법의 집합 속에 녹여 넣는다. 이것이 핵심이다. 여러분은 자신의 공정을 개선하고 다듬기 위해 끊임없이 노력해야 한다. 절대로 어떤 방법론의 완고한 경계를 여러분 세계의 한계로 받아들이면 안 된다.

44. 어떤 방법의 거짓된 권위에도 넘어가지 말라. 사람들이 펼치면 몇백 평이 넘을 클래스 다이어그램 종이 뭉치와 유스 케이스 150개를 들고 회의에 들어오더라도, 그 모든 것 역시 여전히 틀릴 가능성이 있는 요구사항과 설계에 대한 그들의 해석일 뿐이다. 어떤 도구의 결과물을 볼 때 비용이 얼마나 들었을지 생각하지 않도록 노력하라.

45. 형식적 방법들은 분명 개발 과정에서 자기 자리가 있다. 하지만, 프로젝트의 철학이 "클래스 다이어그램이 바로 애플리케이션이다. 나머지는 기계적인 코딩일 뿐이다."인 프로젝트를 보게 된다면, 여러분은 아직도 가야할 길이 먼데 배는 물에 잠겨 들어가는 느낌이 무엇인지 알게 될 것이다.

46. 프로젝트에는 최소한 '우두머리(head)'가 둘 필요하다. 하나는 기술을 담당하는 수석, 나머지 하나는 관리를 담당하는 수석. 기술 수석은 개발 철학과 스타일을 정하며 팀에 책임을 할당하고, 사람들 사이의 피할 수 없는 '토론'을 중재한다. 기술 수석은 지속적으로 큰 그림을 보고, 팀 사이의 불필요한 중복을 찾아 전체 노력의 직교성을 닐이려고 노력한다. 관리 수석, 혹은 프로젝트 매니저는 각 팀이 필요로 하는 자원을 계획(schedule)하고, 진척도를 모니터하고, 그에 대해 보고하며, 비즈니스 가치의 관점에서 우선순위를 결정하는 데에 도움을 준다. 관리 수석은 팀이 바깥 세상과 대화하는 외교관 역할을 한다.

47. 팀은 개인들로 이루어진다는 사실을 명심하라. 각 팀원이 자신의 방식대로 빛나게 해 주어라. 그들을 지원하기에, 그리고 프로젝트가 요구사항에 맞게 이루어지기에 딱 좋을 만큼의 구조를 제공하라.

48. 생각 없이 행할 수 있는 중요한 작업의 수가 늘어남에 따라 문명은 발전한다. - 알프레드 노스 화이트헤드(Alfred North Whitehead)

49. 일찍 테스트하고, 자주 테스트하라. 자동으로 테스트하라.

50. 코드를 작성하자마자 테스트해야 한다. 그 작은 잔챙이들은 꽤나 빨리 자라나 사람을 잡아먹는 거대한 상어가 되는 고약한 성질이 있다. 상어를 잡는 일은 상당히 힘들다. 하지만 그렇다고 그 모든 테스트를 손으로 할 수는 없다.

51. 빌드할 때마다 하는 테스트는 책장에 꽂아 놓은 테스트 계획보다 훨씬 효과적이다.

52. 수행해야할 소프트웨어 테스트에는 대여섯 가지 주요 유형이 있다.
- 단위 테스트
- 통합 테스트
- 유효성 평가(validation)와 검증(verification)
- 자원 고갈, 에러, 그리고 복구
- 성능(performance) 테스트
- 사용편의성(usability) 테스트

53. 단위 테스트  
단위 테스트는 하나의 모듈을 테스트하는 코드다.

54. 통합 테스트  
통합 테스트는 프로젝트를 구성하는 주요 서브시스템이 다른 부분과 제대로 작동하는지 보여준다.

55. 유효성 평가와 검증  
실행가능한 사용자 인터페이스나 프로토타입이 갖춰지자마자, 다음과 같은 가장 중요한 질문에 대답해야 한다. 사용자들은 무엇이 필요한지 이야기해 줬지만, 그게 정말 사용자들이 필요로 하는 것인가?

56. 자원 고갈, 에러 그리고 복구  
이상적인 상황 아래서 시스템이 올바르게 작동한다는 확신이 섰다면, 이제 시스템이 실세계의 상황에서 어떻게 작동할지도 알아야 한다. 실세계에서 프로그램은 무한한 자원을 보장받지 못한다. 여러 가지가 부족하다. 코드는 다음을 포함한 몇 가지 제한 사항에 맞닥뜨릴 것이다.
- 메모리
- 디스크 공간
- CPU 대역폭
- 벽시계 시간(wall-clock time)
- 디스크 대역폭
- 네트워크 대역폭
- 칼라 팔레트
- 비디오 해상도

57. 성능 테스트  
성능 테스트, 스트레스 테스트, 혹은 부하가 걸린 상태에서의 테스트 역시 프로젝트의 중요한 부분이다.  
소프트웨어가 실세계 조건에서 성능 요구사항들을 만족하는지 자문해 보라. 초당 예상 사용자 및 접속 혹은 트랜잭션 숫자를 염두에 두고 말이다. 

58. 사용편의성 테스트  
사용편의성(usability) 테스트는 이제까지 논의했던 테스트 유형과 차이가 있다. 실제 환경의 조건 하에서 실제 사용자들이 시행한다.  ...   
유효성 평가와 검증과 마찬가지로, 사용편의성 테스트는 보정할 시간이 있을 때에 되도록 일찍 시행해야 한다. 더 큰 프로젝트라면 인간적 요소 전문가들을 영입해야 할지도 모른다.  ...   
사용편의성 기준을 충족하지 못하는 것은 0으로 나누기를 하는 것만큼이나 커다란 버그다.

59. 어떻게 테스트할까  
- 회귀 테스트
- 테스트 데이터
- GUI 시스템 구동
- 테스트를 테스트하기
- 철저히 테스트하기

60. 회귀 테스트  
회귀 테스트는 이전(혹은 알려진) 값과 현재 테스트의 출력을 비교한다. 오늘 고친 버그가 어제 작동하던 것들을 망치지 않는다고 확신할 수 있다.

61. 테스트 데이터  
이런 테스트들을 실행할 데이터는 어디에서 얻나? 여기에는 오직 두 종류의 데이터가 있다. 실세계 데이터와 합성데이터다. 실제로는 이 둘을 모두 사용해야 하는데, 두 데이터가 갖는 다른 특징들이 소프트웨어에서 다른 종류의 버그를 노출시켜 주기 때문이다.

62. 다익스트라는 "테스팅은 버그의 존재만 보여줄 수 있지 버그의 부재까지는 보여줄 수 없다"는 명언을 했다. 그렇다면 그가 생각하는 버그를 없게 만드는 방법은? 수학적 증명과 단순화. 토니 호아의 다음 명언이 힌트가 될 것 같다. "소프트웨어 설계를 구축하는 두 가지 방법이 있다. 하나는 아주 단순하게 만들어서 명백히 결함이 없도록 하는 것이고, 다른 하나는 아주 복잡하게 만들어서 명백한 결함이 없도록 하는 것이다."

63. 심지어 훌륭한 코드 커버리지가 있어도 테스트를 위해 사용하는 데이터는 여전히 상당한 영향을 미칠 뿐 아니라, 이보다 더 중요하게, 여러분이 코드를   순서가 가장 큰 영향을 미칠 수 있다.

64. 우린 자동화 테스트가 우리를 대신해 찾아 줄 버그까지 추격할 시간이 없다. 우리는 새 코드를 (그리고 새 버그도) 작성하는 데 시간을 보내야 한다.

65. 실용주의 프로그래머들은 문서화를 전체 개발 프로세스의 필요불가결한 부분으로 포용한다. 노력을 중복하거나 시간을 낭비하지 않고, 문서를 늘 손에 닿는 가까이에 두면 - 가능하다면 코드 속에 - 문서 작성이 더 쉬워진다.

66. 현실적으로 프로젝트의 성공은 사용자들의 기대를 얼마나 잘 충족하는가에 따라 측정된다. 그들의 기대에 못 미치는 프로젝트는 이론적인 면에서 결과물이 얼마나 훌륭하건 간에 상관없이 실패로 간주된다. 어쨌거나 값싼 인형을 기대했던 아이의 부모처럼, 기대를 너무 지나쳐 버려도 역시 실패할 것이다.

67. 사용자의 기대를 부드럽게 넘어서라.

68. 그들이 기대하는 것보다 조금만 더 해주어라. 약간의 노력을 들여 시스템에 사용자 편의를 위한 기능을 추가한다면, 관계가 두고두고 좋아질 것이다.

69. 어떤 기능이 진정 사용자를 기쁘게 할 것인지 단서를 잡아내기 위해서 프로젝트 진행 중에 사용자의 말에 귀를 기울여라. 일반적인 사용자라면 좋아할 만하면서도 상대적으로 손쉽게 추가할 수 있는 기능에는 다음과 같은 것들이 있다.
- 풍선 혹은 툴 팁 도움말
- 키보드 단축키
- 사용자 매뉴얼의 부록으로 만든 빠른 참조
- 색깔 입히기
- 로그 분석기
- 자동 설치
- 시스템의 상태를 체크하는 도구
- 훈련 목적으로 여러 버전의 시스템을 실행시킬 수 있는 기능
- 각 회사나 조직을 위해 만든 스플래시 스크린

70. 익명성은 특히 큰 프로젝트에서 적당주의, 실수, 태만 그리고 나쁜 코드의 번식지가 될 수 있다. 이렇게 되면 훌륭한 코드 대신 끝없는 상황 보고 속에서 어설픈 변명만 생산해 내는 거대한 기계의 한 부속품으로 스스로 전락해 가기 쉽다.

71. 코드에는 주인이 있어야 하지만 꼭 개인일 필요는 없다. 실제로, 성공적이라 할 수 있는 켄트 벡(Kent Beck)의 익스트림 프로그래밍(eXtreme Programming) 방법에서는 코드에 대해 공동 소유권을 제안한다. (하지만 이는 익명성의 위험을 예방하기 위해, 짝 프로그래밍과 같은 추가 수행법을 필요로 한다.)

72. 우리는 소유권에 대한 긍지를 보고 싶다. "내가 이걸 만들었고, 내 작품의 품질을 보증합니다." 여러분의 서명이 품질의 보증수표로 인식되게 해야 한다. 사람들이 코드에 붙여진 여러분의 이름을 보고 그것이 튼튼하고 잘 작성되고 제대로 테스트되었으며 또 훌륭히 문서화되었을 것이라고 기대하도록 만들자. 진정으로 프로페셔널한 일. 진정한 프로페셔널이 작성한. 실용주의 프로그래머.

73. 앤디 : 윈스턴 처칠의 말을 인용하겠습니다. "절대로 포기하지 말고, 절대로 포기하지 말고, 절대로 포기하지 말라."