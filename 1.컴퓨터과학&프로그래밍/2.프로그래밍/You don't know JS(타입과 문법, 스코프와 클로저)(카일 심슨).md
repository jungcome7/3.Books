# You don't know JS (타입과 문법, 스코프와 클로저)
### 지은이 : 카일 심슨
### 옮긴이 : 이일웅, 최병현
### 출판사 : 한빛미디어
### 읽은 날 : 2020.03.18 ~ 2020.03.20
### 두 번째 읽은 날 : 2020.06.10

# 목차
# Part 1. 타입과 문법
### 1. 타입
### 2. 값
### 3. 네이티브
### 4. 강제변환
### 5. 문법
# Part 2. 스코프와 클로저
### 6. 스코프란 무엇인가
### 7. 렉시컬 스코프
### 8. 함수 vs 블록 스코프
### 9. 호이스팅
### 10. 스코프 클로저
### Appendix A. 다양한 환경의 자바스크립트
### Appendix B. 스코프와 렉시컬 this

# Part 1. 타입과 문법
### 1. 타입
1. 타입으로 null 값을 정확히 확인하려면 조건이 하나 더 필요하다.
var a = null;
(!a && typeof a === “object”); //true

2. “undefined”(값이 없는)와 “undeclared”(선언되지 않은)를 동의어처럼 생각하기 쉬운데, 자바스크립트에서 둘은 완전히 다른 개념이다.
“undefined”는 접근 가능한 스코프에 변수가 선언되었으나 현재 아무런 값도 할당되지 않은 상태를 가리키는 반면, “undeclared”는 접근 가능한 스코프에 변수 자체가 선언조차 되지 않은 상태를 의미한다.

### 2. 값
3. 표현식 void __는 어떤 값이든 ‘무효로 만들어void’, 항상 결괏값을 undefined로 만든다. 기존 값은 건드리지 않고 연산 후 값은 복구할 수 없다.

4. void 연산자는 (어떤 표현식으로부터) 존재하는 곳에서 그 값이 undefined가 되어야 좋을 경우에만 사용하자. 아마도 그렇게 해야 할 경우도 거의 없고 극히 제한적으로 쓰이겠지만 제법 쓸모는 있다.

5. NaN은 경계 값(Sentinel Value)의 일종으로 (또는 특별한 의미를 부여한 평범한 값으로) 숫자 집합 내에서 특별한 종류의 에러 상황(“난 당신이 내준 수학 연산을 해봤지만 실패했어 그러니 여기 실패한 숫자를 도로 가져가!”)을 나타낸다.

6. NaN은 너무 귀하신 몸이라 다른 어떤 NaN과도 동등하지 않다(즉, 자기 자신과도 같지 않다). 사실상 반사성(Reflexive)이 없는(x === x로 식별되지 않는) 유일무이한 값이다. 따라서 NaN !== NaN이다. 좀 이상하긴 하다.

7. NaN은 세상의 모든 언어를 통틀어 “자기 자신과도 동등하지 않은” 유일한 값이다.

8. Number.isNaN() !== isNaN() (Number.isNaN() 권장)

9. 값-복사냐 레퍼런스-복사냐를 여러분 마음대로 결정할 수 없음을 기억하자. 전적으로 값의 타입을 보고 엔진의 재량으로 결정된다.

### 3. 네이티브
10. 짐작하겠지만 네이티브는 사실 내장 함수다.

11. 네이티브란 특정 환경(브라우저 등의 클라이언트 프로그램)에 종속되지 않은, ECMAScript 명세의 내장 객체를 말합니다. 예를 들어 Object, Math, Function, Array, Window, Button 중 네이티비그 아닌 것은 Window, Button 두 가지입니다.

12. 요지는 new String(“abc”)은 “abc”를 감싸는 문자열 래퍼를 생성하며 원시 값 ”abc”는 아니라는 점이다.

13. Array() 생성자 앞에 new를 붙이지 않아도 된다. 붙이지 않아도 붙인 것처럼 작동한다. 즉, Array(1, 2, 3)와 new Array(1, 2, 3)은 결과적으로 같다.

14. 따라서 Array.apply()는 Array() 함수를 호출하는 동시에 { length: 3 } 객체 값을 펼쳐 인자로 넣는다.
var a = Array.apply( null, { length: 3 } );
a; // [ undefined, undefined, undefined ]

15. 지금까지 살펴본 다른 생성자와는 달리, RegExp()는 정규 표현식 패턴을 동적으로 정의할 경우 의미있는 유틸리티다.

16. 네이티브 생성자 Date()와 Error()는 리터럴 형식이 없으므로 다른 네이티브에 비해 유용하다.

17. 심벌은 객체가 아니다. 단순한 스칼라 원시 값이다.

18. 문서화 관례에 따라 String.prototype.XYZ는 String#XYZ로 줄여 쓴다. 다른 .prototype도 마찬가지다.

19. 그러고 보니 Function.prototype은 함수, RegExp.prototype은 정규 표현식, Array.prototype은 배열이다. 참 재미있고 쿨하지 않은가? (글쎄..)

20. 자바스크립트는 원시 값을 감싸는 객체 래퍼, 즉 네이티브(String, Number, Boolean 등)를 제공한다. 객체 래퍼에는 타입별로 쓸 만한 기능이 구현되어 있어 편리하게 사용할 수 있다.
“abc” 같은 단순 스칼라 원시 값이 있을 때, 이 값의 length 프로퍼티나 String.prototype에 정의된 메서드를 호출하면 자바스크립트는 자동으로 원시 값을 ‘박싱’(해당되는 객체 래퍼로 감싼다)하여 필요한 프로퍼티와 메서드를 쓸 수 있게 도와준다.

### 4. 강제변환
21. 차이는 명확하다. ‘명시적 강제변환’은 코드만 봐도 의도적으로 타입변환을 일으킨다는 사실이 명백한 반면, ‘암시적 강제변환’은 다른 작업 도중 불분명한 부수 효과(Side Effect)로부터 발생하는 타입변환이다.
var b = a + “”; // 암시적 강제변환
var c = String(a); // 명시적 강제변환

22. JSON.stringify() 이야기가 나왔으니, 잘 알려지지 않은 유용한 기능 하나를 귀띔하겠다.
배열 아니면 함수 형태의 대체자(Replacer)를 JSON.stringify()의 두 번째 선택 인자로 지정하여 객체를 재귀적으로 직렬화하면서 (포함할 프로퍼티와 제외할 프로퍼티를 결정하는) 필터링 하는 방법이 있다.

23. JSON.stringify()은 세 번째 선택 인자는 스페이스(Space)라고 하며 사람이 읽기 쉽도록 들여 쓰기를 할 수 있다. 들여 쓰기를 할 빈 공간의 개수를 숫자로 지정하거나 문자열(10자 이상이면 앞에서 10자까지만 잘라 사용한다)을 지정하여 각 들여 쓰기 수준에 사용한다.

24. ‘숫자 아닌 값 -> 수식 연산이 가능한 숫자’ 변환 로직  
예를 들어 true는 1, false는 0이 된다. Undefined는 NaN으로, (희한하게도) null은 0으로 바뀐다.

25. 명세가 정의한 ‘falsy’ 값은 다음과 같다.  
- undefined
- null
- false
- +0, -0, NaN
- “”

26. 오픈 소스 자바스크립트 커뮤니티에서는 + 단항 연산자를 명시적 강제변환 형식으로 대부분 인정하는 분위기다.

27. 가급적 +/- 단항 연산자를 다른 연산자와 인접하여 사용하지 않기 바란다. 코드가 잘 돌아간다해도 별로 좋지 않은 생각이다.

28. ~x는 대략 –(x+1)와 같다. 이상한 것 같지만 왜 그런지 금방 알 수 있다.
~42; // -(42+1)  -43

29. 그러나 ~~ 사용시 유의할 점이 있다. 우선 ~~ 연산은 32비트 값에 한하여 안전하다. 그런데 그보다도 음수에서는 Math.floor()과 결괏값이 다르다는 사실을 조심하자!
Math.floor(-49.6); // -50
~~49.6; // -49
Math.floor()과의 다른 점은 차치하더라도 ~~x는 (32비트) 정수로 상위 비트를 잘라낸다. 하지만 같은 일을 하는 x | 0가 (조금이라도) 더 빠를 것 같다.

30. 인자가 비 문자열(Non-String)이면 제일 먼저 자동으로 문자열로 강제변환한다. 이는 일종의 감춰진 암시적 강제변환으로 프로그램에 이런 로직이 자꾸 들어가는 건 바람직하지 않다. 절대로 parseInt()에 비 문자열 값을 넘기지 말자.

31. 암시적 강제변환이 무엇인지, 어떻게 활용할지, 무조건 ‘선량한 명시적 강제변환의 적’으로 몰아가지만 말고 조금 다른 시각에서 바라보자! 너무 편협하고 중요한 의미를 놓치고 있는 것 같아 안쓰럽다.
암시적 강제변환의 목적은 중요한 내용으로부터 주의를 분산시켜 코드를 잡동사니로 가득 채워버리는 장황함(Verbosity), 보일러플레이트(Boilerplate), 불필요한 상세 구현을 줄이는 것이다.

32. b = String(a)(명시적)과 b = a + “”(암시적)를 비교해보자. 둘 다 경우에 따라 유용하게 코드에 쓰일 수 있지만 자바스크립트 프로그램에선 후자를 훨씬 더 많이 쓴다. 이것만 보더라도 암시적 강제변환이 좋다, 나쁘다 하는 감정과는 무관하게 그 가치를 인정받았다는 걸 알 수 있다.

33. 개발자가 직접 손으로 코딩하기보다는 자바스크립트 압축기(Minifier)에서 더 많이 쓰는, 또 다른 관용 코드가 있다. && 연산자는 첫 번째 피연산자의 평가 결과가 truthy일 때에만 두 번째 피연산자를 ‘선택’한다고 했는데 이런 특성을 ‘가드 연산자(Guard Operator)’라고 한다. 첫 번째 표현식이 두 번째 표현식의 ‘가드’ 역할을 하는 것이다.

34. 정확한 정의를 내리겠다. “동등함 비교시 ==는 강제변환을 허용하지만, ===는 강제변환을 허용하지 않는다.”

35. 어떠한 일이 있더라도, 절대로, 두 번 다시 == true, == false 같은 코드는 쓰지 말라고 개인적으로 강권하고 싶다.
하지만 여기서 쓰지 말라고 한 연산자는 ==이지, ===이 아니다. === true, === false는 강제변환을 허용하지 않기에 ToNumber 강제변환 따위는 신경 쓰지 않아도 된다.

36. null과 undefined를 느슨한 동등 비교(==)하면 서로에게 타입을 맞춘다(강제변환한다). 언어 전체를 눈 씻고 찾아봐도 다른 값은 끼어들 여지가 없다.
즉, null과 undefined는 느슨한 동등 비교시 상호 간의 암시적인 강제변환이 일어나므로 비교 관점에서 구분이 되지 않는 값으로 취급되는 것이다.

37. (강제변환의) 나쁜 부분 7인방을 모아 보자.
- “0” == false; // true
- false == 0; //true
- false == “”; // true
- false == []; // true
- “” == 0; // true
- “” == []; // true
- 0 == []; // true

38. 결국, 강제변환 때문에 골탕 먹을 경우의 수가 있다는 사실은 부인하기 어렵고 함정에 빠지지 않으려면 주의할 필요는 있지만, 코드 베이스 전체를 통틀어 그럴 만한 코드가 나올 가능성은 매우 희박하다는 걸 알 수 있다.

39.  
- 피연산자 중 하나가 true/false일 가능성이 있으면 ‘절대로’ == 연산자를 쓰지 말자.
- 피연산자 중 하나가 [], “ “, 0이 될 가능성이 있으면 가급적 == 연산자는 쓰지 말자.
이런 상황이라면 == 대신 ===를 사용하여 여러분이 의도하지 않은 강제변환을 차단하는 게 훨씬 좋다. 이 두 가지 원칙만 준수해도 웬만한 강제변환의 함정들은 효과적으로 피해갈 수 있으리라 생각한다.

40. 결국 ==냐 ===냐 하는 문제는 한 마디로 “동등 비교 시 강제변환을 허용할 거냐 말 거냐”와 본질적으로 같다.

41. a <= b는 실제로 b < a의 평과 결과를 부정하도록 명세에 기술되어 있기 때문이다. 그래서 b < a가 false이므로 a <= b는 이를 부정한 true가 된다.

42. 여러분은 지금까지 <=이 ‘같거나 더 작은’이라는 부등호의 의미일 거라 당연시해왔겠지만, 참 짓궂게도 정반대일 가능성도 있다. 실제로 자바스크립트 엔진은 <=를 ‘더 크지 않은’(!(a > b) -> !(b < a)로 처리)의 의미로 해석한다. 더구나 a >= b는 먼저 b <= a로 재해석한 다음 동일한 추론을 적용한다.

43. 명시적 강제변환은 다른 타입의 값으로 변환하는 의도가 확실한 코드를 말하며 혼동의 여지를 줄이고 코드 가독성 및 유지 보수성을 높일 수 있는 장점이 있다.
암시적인 강제변환은 ‘숨겨진’ 로직에 의한 부수 효과가 있으며 타입변환이 처리되는 과정이 명확하지 않다. 그래서 암시적 강제변환이 명시적 강제변환의 정반대고 나쁜 것이라고들 하지만 (주변에 이렇게 얘기하는 사람들이 의외로 많다!) 실은 암시적 강제변환이 오히려 코드 가독성을 향상하는 장점도 있다.

44. 암시적 강제변환은 변환 과정이 구체적으로 어떻게 일어나는지 명확하게 알고 사용해야 한다. 여러분 스스로 지금 내가 무슨 코드를 짜고 있고 어떻게 작동할 거란 점은 알고 있어야 한다. 더 나아가 다른 개발자들도 쉽게 배우고 이해할 수 있는 코드를 작성하도록 노력하기 바란다.

### 5. 문법
45. continue foo는 “foo라는 레이블 위치로 이동하여 계속 순회하라”는 의미가 아니라 “foo라는 레이블이 붙은 루프의 다음 순회를 계속하라”는 뜻이다. 따라서 사실 임의적인 goto와는 다르다.

46. 레이블 루프/블록은 사용 빈도가 극히 드물고 못마땅한 구석도 많아 가능한 한 피하는 게 상책이다. 이를테면 루프 점프를 할 바에야 차라리 함수 호출이 더 낫다. 하지만 제한적이나마 도움이 되는 경우가 없지 않으므로, 만약 레이블 점프 기능을 사용할 의도라면 여러분이 뜻한 바를 상세한 주석으로 잘 문서화하기 바란다!

46. 자바스크립트 문의 레이블은 따옴표를 감싸면 안 되기 때문에 “a:는 문법에 맞는 레이블이 아니며, 그래서 : 이 그 뒤에 오면 d나 된다. 따라서 JSON은 자바스크립트 구문의 하위 집합이라 할 수 있지만, 그 자체로 올바른 자바스크립트 문법은 아니다.

47. 다수의 문을 연결하는 연산자로 ,를 사용할 때에는 이 연산자의 우선순위가 최하위라는 사실 또한 반드시 알고 있어야 한다. 즉, 어떤 연산자라도 ,보다 먼저 묶인다.

48. &&는 언제나 || 보다 먼저 평가된다는 사실이 증명되었다.

49. 세미콜론 자동 삽입  
ASI(Automatic Semicolon Insertion, 자동 세미콜론 삽입)는 자바스크립트 프로그램의 세미콜론(;)이 누락된 곳에 엔진이 자동으로 ;을 삽입하는 것을 말한다.

50. 자바스크립트 코딩시 ;을 안 써도 될 것 같은 부분에 생략을 해도 프로그램이 실행되는 이유는 모두 ASI 덕분이다. 단, ASI는 새 줄(행 바꿈, Line Break)에만 적용되며 어떠한 경우에도 줄 중간에 삽입되는 일은 없다.

51. ES6는 ‘임시 데드 존(TDZ, Temporal Dead Zone)’이라는 새로운 개념을 도입했다. TDZ는 아직 초기화를 하지 않아 변수를 참조할 수 없는 코드 영역이다.

52. 만약 finally 절에서 (사고든, 고의든) 예외가 던져지면, 이전의 실행 결과는 모두 무시한다. 즉, 이전에 try 블록에서 생성한 완료 값이 있어도 완전히 사장된다.

# Part 2. 스코프와 클로저
### 6. 스코프란 무엇인가
53. 어떤 자바스크립트 조각이라도 실행되려면 먼저 (보통 바로 직전에!) 컴파일되어야 한다는 것이다. 즉, 자바스크립트 컴파일러는 프로그램 “var a = 2;”를 받아 컴파일하여 바로 실행될 수 있게 한다.

54. 
1) 컴파일러가 ‘var a’를 만나면 스코프에게 변수 a가 특정 스코프 컬렉션 안에 있는지 묻는다. 변수 a가 이미 있다면 컴파일러는 선언을 무시하고 지나가고, 그렇지 않으면 컴파일러는 새로운 변수 a를 스코프 컬렉션 내에 선언하라고 요청한다.
2) 그 후 컴파일러는 ‘a = 2’ 대입문을 처리하기 위해 나중에 엔진이 실행할 수 있는 코드를 생성한다. 엔진이 실행하는 코드는 먼저 스코프에게 a라 부르는 변수가 현재 스코프 컬렉션 내에서 접근할 수 있는지를 확인한다. 가능하다면 엔진은 변수 a를 사용하고, 아니라면 엔진은 다른 곳을 살핀다.
엔진이 마침내 변수를 찾으면 변수에 값 2를 넣고, 못 찾는다면 엔진은 손을 들고 에러가 발생했다고 소리칠 것이다. 요약하면, 별개의 두 가지 동작을 취하여 변수 대입문을 처리한다. 첫째, 컴파일러가 변수를 선언한다(현재 스코프에 미리 변수가 선언되지 않은 경우). 둘째, 엔진이 스코프에서 변수를 찾고 변수가 있다면 값을 대입한다.

55. 스코프는 어디서 어떻게 변수(확인자)를 찾는가를 결정하는 규칙의 집합이다. 변수를 검색하는 이유는 변수에 값을 대입하거나(LHS 참조) 변수의 값을 얻어오기 위해서다(RHS 참조)

### 7. 렉시컬 스코프
56. 스코프는 목표와 일치하는 대상을 찾는 즉시 검색을 중단한다.

57. 섀도잉과 상관없이 스코프 검색은 항상 실행 시점에서 가장 안쪽 스코프에서 시작하여 최초 목표와 일치하는 대상을 찾으면 멈추고, 그전까지는 바깥/위로 올라가면서 수행한다.

58. 자바스크립트에는 렉시컬 스코프를 속이는 두 가지 방식이 있는데, eval()과 with다. Eval()은 하나 이상의 선언문을 포함하는 코드 문자열을 해석하여 렉시컬 스코프가 있다면 런타임에 이를 수정한다. With는 객체 참조를 하나의 스코프로, 속성을 확인자로 간주하여 런타임에 완전히 새로운 렉시컬 스코프를 생성한다.
이런 방식의 단점은 eval()과 with가 엔진이 컴파일 단계에서 수행한 스코프 검색과 관련된 최적화 작업을 무산시킨다는 점이다. 이들이 수행되면 엔진은 최악의 경우를 대비해 진행했던 최적화 결과가 무효화됐다고 가정해야 하기 때문이다. 따라서 eval()과 with 중 하나라도 사용하면 코드는 더 느리게 동작하므로 이 방식은 사용하지 말자.

### 8. 함수 vs 블록 스코프
59. 이 원칙은 어떤 스코프가 변수와 함수를 포함하는지에 관한 문제와도 관련이 있다. 모든 변수와 함수가 글로벌 스코프에 존재한다면 어느 중첩된 하위 스코프에서도 이들에 접근할 수 있다. 이는 ‘최소…’의 원칙을 어기는 것이고, 코드를 적절하게 사용했을 때 접근할 필요가 없어서 비공개로 남겨둬야 할 많은 변수나 함수를 노출시키게 된다.

60. 명시적으로 블록을 선언하여 변수의 영역을 한정하는 것은 효과적인 코딩 방식이므로 익혀두면 좋다.

### 9. 호이스팅
61. 변수와 함수 선언문은 선언된 위치에서 코드의 꼭대기로 ‘끌어올려’ 진다. 이렇게 선언문을 끌어올리는 동작을 ‘호이스팅(Hoisting)’이라고 한다. 즉 달결(선언문)이 닭(대입문)보다 먼저다.

62. 함수가 먼저다  
함수와 변수 선언문은 모두 끌어올려진다. 그러나 (코드에서 여러 개의 ‘중복’선언을 하면 확인할 수 있는) 미묘한 차이가 있는데, 먼저 함수가 끌어올려지고 다음으로 변수가 올려진다.

63. 블록 내 함수 선언은 지양하는 것이 가장 좋다.

64. “var a = 2;”는 하나의 구문처럼 보이지만, 자바스크립트 엔진은 그렇게 보지 않는다. 엔진은 이를 “var a”와 “a = 2”라는 두 개의 독립된 구문으로 보고, 첫째 구문은 컴파일러 단계에서 처리하고 둘째 구문은 실행 단계에서 처리한다.

### 10. 스코프 클로저
65. 깨달음의 순간이 이럴 것이다. “아, 클로저는 내 코드 전반에서 이미 일어나고 있었구나! 이제 난 클로저를 볼 수 있어.” 클로저를 이해하는 것은 네오가 매트릭스를 처음 봤을 때와 같을 것이다.

66. 클로저는 함수가 속한 렉시컬 스코프를 기억하여 함수가 렉시컬 스코프 밖에서 실행될 때에도 이 스코프에 접근할 수 있게 하는 기능을 뜻한다.

67. 어떤 방식으로 내부 함수를 자신이 속한 렉시컬 스코프 밖으로 수송하든 함수는 처음 선언된 곳의 스코프에 대한 참조를 유지한다. 즉, 어디에서 해당 함수를 실행하든 클로저가 작용한다.

68. 그러나 그게 다가 아니다! Let 선언문이 for 반복문 안에서 사용되면 특별한 방식으로 작동한다. 반복문 시작 부분에서 let으로 선언된 변수는 한 번만 선언되는 것이 아니라 반복할 때마다 선언된다. 따라서 해당 변수는 편리하게도 반복마다 이전 반복이 끝난 이후의 값으로 초기화된다.

69. 멋지지 않은가? 블록 스코프와 클로저가 함께 활약해서 모든 문제를 해결했다. 여러분은 어떨지 모르지만, 나는 자바스크립트 사용자로서 무척 기쁘다.

70. 이 모듈 패턴을 사용하려면 두 가지 조건이 있다.
1) 하나의 최외곽 함수가 존재하고, 이 함수가 최소 한 번은 호출되어야 한다(호출할 때마다 새로운 모듈 인스턴스가 생성된다).
2) 최외곽 함수는 최소 한 번은 하나의 내부 함수를 반환해야 한다. 그래야 해당 내부 함수가 비공개 스코프에 대한 클로저를 가져 비공개 상태에 접근하고 수정할 수 있다.
하나의 함수 속성만을 가지는 객체는 진정한 모듈이 아니다. 함수 실행 결과로 반환된 객체에 데이터 속성들은 있지만 닫힌 함수가 없다면, 당연히 그 객체는 진정한 모듈이 아니다.

### Appendix A. 다양한 환경의 자바스크립트
71. 자바스크립트의 공식적인 언어 명칭이 ECMAScript(ECMA는 표준 관리 주체 기관임)라는 사실은 그리 잘 알려져 있지 않다. 그럼 ‘자바스크립트’는? 자바스크립트는 ECMAScript 언어의 상품명으로 통용되며, 더 정확하게는 명세의 브라우저 구현체다.

### Appendix B. 스코프와 렉시컬 this
72. 정확하게 말하면 자바스크립트는 동적 스코프를 사용하지 않고 렉시컬 스코프만 사용한다. 단, this 메커니즘이 동적 스코프와 비슷한 면이 있다.
주요 차이점은 다음과 같다.
- 렉시컬 스코프는 작성할 때, 동적 스코프는 (그리고 this)는 런타임에 결정된다.
- 렉시컬 스코프는 어디서 함수가 선언됐는지와 관련 있지만, 동적 스코프는 어디서 함수가 호출됐는지와 관련있다.

---
### 두 번째 Reading

# Part 1. 타입과 문법
### 1. 타입
1. 자바스크립트에는 다음 7가지 내장 타입이 있다.
- null
- undefined 
- boolean
- number
- string
- object
- symbol
(object를 제외한) 이들을 '원시 타입(Primitives)'이라 한다.

2. 정리하기  
자바스크립트에는 7가지 내장 타입(null, undefined, boolean, number, string, object, symbol)이 있으며, typeof 연산자로 타입명을 알아낸다.  
변수는 타입이 없지만 값은 타입이 있고, 타입은 값의 내재된 특성을 정의한다.  
"undefined"와 "undeclared"가 대충 같다고 보는 개발자들이 많은데, 자바스크립트 엔진은 둘을 전혀 다르게 취급한다. undefined는 선언된 변수에 할당할 수 있는 값이지만, undeclared는 변수 자체가 선언된 적이 없음을 나타낸다.  
불행히도 자바스크립트는 이 두 용어를 대충 섞어버려, 에러 메시지("ReferenceError: a is not defined")뿐만 아니라 typeof 반환 값도 모두 "undefined"로 뭉뚱그린다.  
그래도 (에러를 내지 않는) typeof 안전 가드 덕분에 선언되지 않은 변수에 사용하면 제법 쓸 만하다.

### 2. 값
3. 
- null은 빈 값이다.
- undefined는 실종된(Missing) 값이다. 
또는  
- null은 예전에 값이 있었지만 지금은 없는 상태다.
- undefined는 값을 아직 가지지 않은 것이다.

4. 드디어 ES6부터는 해결사 Number.isNaN()이 등장한다.

5. null, undefined, string, number, boolean 그리고 ES6의 symbol 같은 단순 값(스칼라 원시 값Scalar Primitives)은 언제나 값-복사 방식으로 할당/전달된다.  
객체(배열과 박싱된 객체 래퍼 전체)나 함수 등 합성 값(Compound Values)은 할당/전달 시 반드시 레퍼런스 사본을 생성한다.

6. 하지만, c와 d는 모두 합성 값이자 동일한 공유 값 [1,2,3]에 대한 개별 레퍼런스다. 여기서 기억해야 할 점은 c와 d가 [1,2,3]을 '소유'하는 것이 아니라 단지 이 값을 동등하게 참조만 한다는 사실이다. 따라서 레퍼런스로 실제 공유한 배열 값이 변경되면(.push(4)), 이 공유 값 한 군데에만 영향을 미치므로 두 레퍼런스는 갱신된 값 [1,2,3,4]를 동시에 바라보게 된다.

7. 레퍼런스는 꽤 강력하지만 이따금 걸림돌이 되기도 하고 심지어 존재하지도 않는 레퍼런스를 찾아 정처 없이 헤매기도 한다. 값-복사냐 레퍼런스-복사냐를 결정하는 유일한 단서는 값의 타입뿐이므로 사용할 값 타입을 잘 정해서 간접적으로 할당/전달 로직에 반영해야 한다.

8. 정리하기  
자바스크립트 배열은 모든 타입의 값들을 숫자로 인덱싱한 집합이다. 문자열은 일종의 '유사 배열'이지만, 나름 특성이 있기 때문에 배열로 다루고자 할 때에는 조심하는 것이 좋다. 자바스크립트 숫자는 '정수'와 '부동 소수점 숫자' 모두 포함한다.  
원시 타입에는 몇몇 특수 값이 있다.  
null 타입은 null이란 값 하나뿐이고, 마찬가지로 undefined 타입도 같은 undefined뿐이다. undefined는 할당된 값이 없다면 모든 변수/프로퍼티의 디폴트 값이다. void 연산자는 어떤 값이라도 undefined로 만들어 버린다.  
숫자에는 NaN(설명은 '숫자 아님'이지만, 사실 '유효하지 않은 숫자'라고 해야 더 정확함), +Infinity, -Infinity, -0 같은 특수 값이 있다.  
단순 스칼라 원시 값(문자열, 숫자 등)은 값-복사에 의해, 합성 값(객체 등)은 레퍼런스-복사에 의해 값이 할당/전달된다. 자바스크립트에서의 레퍼런스는 다른 언어의 레퍼런스/포인터와는 전혀 다른 개념으로, 또 다른 변수/레퍼런스가 아닌 오직 자신의 값만을 가리킨다.

### 3. 네이티브
9. 짐작하겠지만 네이티브는 사실 내장 함수다.

10. 네이티브(Native)란 말은 자바스크립트 계에서 여기저기 남용되는 경향이 있습니다. 영어 단어의 의미를 상기하여 기본적인 정의를 내린다면, 네이티브란 특정 환경(브라우저 등의 클라이언트 프로그램)에 종속되지 않은, ECMAScript 명세의 내장 객체를 말합니다. 예를 들어 Object, Math, Function, Array, Window, Button 중 네이티브가 아닌 것은 Window, Button 두 가지입니다.

11. 따라서 Array.apply()는 Array() 함수를 호출하는 동시에 { length: 3 } 객체 값을 펼쳐 인자로 넣는다.  
var a = Array.apply(null, {length : 3})
a; // [undefined, undefined, undefined]

12. 심벌을 직접 정의하려면 Symbol() 네이티브를 사용한다. Symbol()은 앞에 new를 붙이면 에러가 나는, 유일한 네이티브 '생성자'다.

13. 정리하기  
자바스크립트는 원시 값을 감싸는 객체 래퍼, 즉 네이티브(String, Number, Boolean 등)를 제공한다. 객체 래퍼에는 타입별로 쓸 만한 기능이 구현되어 있어 편리하게 사용할 수 있다(예: String#trim(), Array#concat() 등).  
"abc" 같은 단순 스칼라 원시 값이 있을 때, 이 값의 length 프로퍼티나 String.prototype에 정의된 메서드를 호출하면 자바스크립트는 자동으로 원시 값을 '박싱'(해당되는 객체 래퍼로 감싼다)하여 필요한 프로퍼티와 메서드를 쓸 수 있게 도와준다.

### 4. 강제변환
14. 정리하기  
명시적 강제변환은 다른 타입의 값으로 변환하는 의도가 확실한 코드를 말하며 혼동의 여지를 줄이고 코드 가독성 및 유지 보수성을 높일 수 있는 장점이 있다.  
암시적인 강제변환은 '숨겨진' 로직에 의한 부수 효과가 있으며 타입변환이 처리되는 과정이 명확하지 않다. 그래서 암시적 강제변환이 명시적 강제변환의 정반대고 나쁜 것이라고들 하지만(주변에 이렇게 얘기하는 사람들이 의외로 많다!) 실은 암시적 강제변환이 오히려 코드 가독성을 향상하는 장점도 있다.  
암시적 강제변환은 변환 과정이 구체적으로 어떻게 일어나는지 명확하게 알고 사용해야 한다. 여러분 스스로 지금 내가 무슨 코드를 짜고 있고 어떻게 작동할 거란 점은 알고 있어야 한다. 더 나아가 다른 개발자들도 쉽게 배우고 이해할 수 있는 코드를 작성하도록 노력하기 바란다.

### 5. 문법
15. 문(Statement)과 표현식(Expression)을 대충 같은 의미라고 넘겨버리는 개발자가 허다하다. 그러나 자바스크립ㄴ트에서 두 용어는 아주 중요한 차이가 있으므로 명확하게 분별하자.  
확실히 구분 짓기 위해 여러분이 좀 더 익숙한 영어의 용어를 빌려보자.  
'문장Sentence'은 생각을 표현하는 단어들의 완전한 조형물이다. 문장은 하나 이상의 '어구Phrase'로 구성되며, 각 어구는 구두점Punctuation Mark이나 접속사Conjunction(그리고, 또는 등)로 연결할 수 있고 어구는 더 작은 어구로 나눌 수 있다. 어떤 어구는 불완전하여 그 자체로 완성된 문장을 형성할 수 없지만 스스로의 힘만으로 완성되는 어구도 있다. 이러한 규칙들을 통틀어 영어 언어의 문법이라고 한다.  
자바스크립트 문법도 마찬가지다. 문Statement은 문장Sentence, 표현식Expression은 어구Phrase, 연산자는 구두점/접속사에 해당된다. 자바스크립트에서 모든 표현식은 단일한, 특정한 결괏값으로 계산된다. 예를 들면  
var a = 3 * 6;
var b = a;
b;
여기서 3 * 6은(18이라는 값으로 평가되는) 표현식이다. 두 번째 줄 역시 표현식이며, 세 번째 줄 b도 표현식이다. a, b 표현식 모두 당시 변수들에 저장된 값으로 평가되므로 b 역시 18이 된다. 게다가 이 세 줄은 각각 표현식이 포함된 문이다. var a = 3 * 6, var b = a 두 문은 각각 변수를 선언(그리고 선택적으로 동시에 어떤 값을 할당)하므로 '선언문Declaration Statement'이라 한다. (앞에 var가 빠진) a = 3 * 6나 b = a는 '할당 표현식Assignment Expression'이라고 한다.  
세 번째 줄은 b가 표현식의 전부지만 이것만으로도 완전한 문이다(그다지 흥미를 유발하는 문은 아니지만!). 일반적으로 이런 문을 '표현식 문Expression Statement'이라고 일컫는다.

16. 정리하기  
자바스크립트 문법에는 우리 같은 개발자들이 평소 하던 것보다 더 많은 시간을 들여 관심 있게 봐야 할 오묘한 것들이 꽤 많다. 약간의 노력만 기울이면 여러분도 좀 더 깊이 있는 자바스크립트 지식을 다지는 데 큰 도움이 될 것이다.  
문과 표현식은 영어 언어의 문장, 어구와 각각 유사하다. 표현식은 순수하고 독립적이지만 부수 효과를 일으킬 수 있다.  
자바스크립트 문법에는 순수 구문 외에 의미론적인 사용 규칙(콘텍스트)이 내재되어 있다. 예를 들어, 프로그램에서 자주 등장하는 {} 쌍은 문 블록, 객체 리터럴이 될 수도 있고, 해체 할당이나 명명된 함수 인자로 쓸 수도 있다.  
자바스크립트 연산자는 그 우선순위(어떤 것이 다른 것보다 먼저 묶여지는지)와 결합성(여러 연산자 표현식이 암시적으로 그룹핑되는 방법)이 분명히 정해져 있다. 일단 우선순위/결합성 규칙을 잘 알아두기 바라며, 두 규칙이 무턱대고 사용하기엔 너무 암시적이라 사용을 자제할지 아니면 짧고 깔끕한 코딩에 도움이 되니 적극 활용할지 판단은 알아서 하자.  
ASI(자동 세미콜론 삽입)는 자바스크립트 엔진에 내장된 '파서 에러 감지 시스템'으로 필요한 ;이 코드에서 누락된 경우 파서 에러가 나면 자동으로 삽입해보고 코드 실행에 문제가 없도록 도와준다. 이런 장치가 준비되어 있어서 대부분의 ;을 선택적으로 쓰는 편이 좋을지(깔끔한 코드를 위해서 쓰지 말자!)원래 넣어야 ;을 개발자가 실수로 빠뜨린 것을 엔진이 대신 뒤처리를 해주는 것에 불과한지 의견이 분분하다.  
자바스크립트 에러는 몇 가지 유형이 있지만 크게 '조기 에러'(컴파일러가 던진 잡을 수 없는 에러)와 '런타임 에러'(try...catch로 잡을 수 있는 에러)로 분류된다는 사실은 별로 잘 알려져 있지 않다. 모든 구문 에러는 프로그램을 실행 전 중단시키는 조기 에러가 분명하지만, 다른 유형의 에러들도 있다.  
함수 arguments와 명명된 인자의 관계는 흥미롭다. arguments 배열은 조심하지 않으면 구멍 난 추상화에서 비롯된 갖가지 함정에 빠질 수 있다. 가급적 arguments 사용을 자제하되 꼭 사용해야 할 경우 arguments의 원소와 이에 대응하는 명명된 인자를 동시에 사용하지 말자.  
try(또는 try...catch)에 붙는 finally 절에는 실행 처리 순서 면에서 별난 기벽이 있다. 때로는 이런 기벽이 도움이 되기도 하지만, 레이블 블록과 함께 사용하면 많은 혼란을 가중시킬 수 있다. 교묘하지만 헷갈리는 코드를 작성하지 말고 finally로 좋은 코드, 깔끔한 코드를 작성하기 바란다.  
switch는 장황한 if...else if... 문을 대체하는 훌륭한 수단이지만, 단순하게만 생각했다간 예기치 않은 결과에 당황할 수 있다. 조심하지 않으면 여러분을 고생시킬 기벽들이 곳곳에 숨어있지만, 꽤 그럴듯한 트릭도 함께 지니고 있다.

# Part 2. 스코프와 클로저
### 6. 스코프란 무엇인가
17. 프로그래밍 언어의 기본 패러다임 중 하나는 변수에 값을 저장하고 저장된 값을 가져다 쓰고 수정하는 것이다. 이 기능은 프로그램에서 상태를 나타낼 수 있게 해준다. 이와 같은 개념이 없다면 프로그램은 상당히 제한적이고 지극히 심심한 작업만 할 수 있을 것이다. 그러나 변수를 프로그램에 추가하면 다음과 같은 재미있는 질문이 생긴다.  
- 변수는 어디에 살아있는가? 다른 말로 하면 변수는 어디에 저장되는가?
- 필요할 때 프로그램은 어떻게 변수를 찾는가?
이 질문을 통해 알 수 있는 것은 특정 장소에 변수를 저장하고 나중에 그 변수를 찾는 데는 잘 정의된 규칙이 필요하다는 점이다. 바로 이런 규칙을 '스코프Scope'라 한다.

18. 컴파일러 이론  
여러 언어를 다루어 봤다면 자명할 수도 있겠고 아니라면 놀라울 수도 있겠지만, 자바스크립트는 일반적으로 '동적' 또는 '인터프리터'언어로 분류하나 사실은 '컴파일러 언어'다. 물론 자바스크립트가 전통적인 많은 컴파일러 언어처럼 코드를 미리 컴파일하거나 컴파일한 결과를 분산 시스템에서 이용할 수 있는 것은 아니다. 하지만 자바스크립트 엔진은 전통적인 컴파일러 언어에서 컴파일러가 하는 일의 상당 부분을 우리가 아는 것보다 세련된 방식으로 처리한다.

19. 
function foo(a) {
    console.log(a+b);
    b=a;
}
foo(2);

b에 대한 첫 RHS 검색이 실패하면 다시는 b를 찾을 수 없다. 이렇게 스코프에서 찾지 못한 변수는 '선언되지 않은 변수'라 한다. RHS 검색이 중첩 스코프 안 어디에서도 변수를 찾지 못하면 엔진이 'ReferenceError'를 발생시킨다. 여기서 중요한 점은 발생된 오류가 ReferenceError 타입이라는 것이다.  
반면에, 엔진이 LHS 검색을 수행하며 변수를 찾지 못하고 최상위 층(글로벌 스코프)에 도착할 때 프로그램이 'Strict Mode'로 동작하고 있는 것이 아니라면, 글로벌 스코프는 엔진이 검색하는 이름을 가진 새로운 변수를 생성해서 엔진에게 넘겨준다. 즉, "없어, 없었지만 내가 널 위해 하나 만들어주지"라고 생각하면 된다.

20. 정리하기  
스코프는 어디서 어떻게 변수(확인자)를 찾는가를 결정하는 규칙의 집합이다. 변수를 검색하는 이유는 변수에 값을 대입하거나(LHS 참조) 변수의 값을 얻어오기 위해서다(RHS 참조)  
LHS 참조는 대입 연산 과정에서 일어난다. 스코프와 관련된 대입 연산은 '=' 연산자가 사용되거나 인자를 함수의 인자로 넘겨줄 때 일어난다.  
자바스크립트 엔진은 코드를 실행하기 전에 먼저 컴파일하는데, 이 과정에서 엔진은 "var a = 2;"와 같은 구문을 독립된 두 단계로 나눈다.  
1) var a는 변수 a를 해당 스코프에 선언한다. 이 단계는 코드 실행 전에 처음부터 수행된다.
2) a = 2는 변수 a를 찾아 값을 대입한다(LHS 참조).  

LHS와 RHS 참조 검색은 모두 현재 실행 중인 스코프에서 시작한다. 그리고 필요하다면 (대상 변수를 찾지 못했을 경우) 한 번에 한 스코프씩 중첩 스코프의 상위 스코프로 넘어가며 확인자를 찾는다. 이 작업은 글로벌 스코프(최상위 층)에 이를 때까지 계속하고 대상을 찾았든, 못 찾았든 작업을 중단한다.  
RHS 참조가 대상을 찾지 못하면 ReferenceError가 발생한다. LHS 참조가 대상을 찾지 못하면 자동적, 암시적으로 글로벌 스코프에 같은 이름의 새로운 변수가 생성된다(만약 'Strict Mode'일 경우 ReferenceError가 발생함).

### 7. 렉시컬 스코프
21. 정리하기  
렉시컬 스코프란 개발자가 코드를 작성할 때 함수를 어디에 선언하는지에 따라 정의되는 스코프를 말한다. 컴파일레이션의 렉싱 단계에서는 모든 확인자가 어디서 어떻게 선언됐는지 파악하여 실행 단계에서 어떻게 확인자를 검색할지 예상할 수 있도록 도와준다.  
자바스크립트에는 렉시컬 스코프를 속이는 두 가지 방식이 있는데, eval()과 with다. eval()은 하나 이상의 선언문을 포함하는 코드 문자열을 해석하여 렉시컬 스코프가 있다면 런타임에 이를 수정한다. with는 객체 참조를 하나의 스코프로, 속성을 확인자로 간주하여 런타임에 완전히 새로운 렉시컬 스코프를 생성한다.  
이런 방식의 단점은 eval()과 with가 엔진이 컴파일 단계에서 수행한 스코프 검색과 관련된 최적화 작업을 무산시킨다는 점이다. 이들이 수행되면 엔진은 최악의 경우를 대비해 진행했던 최적화 결과가 무효화됐다고 가정해야 하기 때문이다. 따라서 eval()과 with 중 하나라도 사용하면 코드는 더 느리게 동작하므로 이 방식은 사용하지 말자.

### 8. 함수 vs 블록 스코프
22. 이 원칙은 어던 스코프가 변수와 함수를 포함하는지에 관한 문제와도 관련이 있다. 모든 변수와 함수가 글로벌 스코프에 존재한다면 어느 중첩된 하위 스코프에서도 이들에 접근할 수 있다. 이는 '최소...'의 원칙을 어기는 것이고, 코드를 적절하게 사용했을 때 접근할 필요가 없어서 비공개로 남겨둬야 할 많은 변수나 함수를 노출시키게 된다.

23. 2부 4장에서는 호이스팅Hoisting(끌어올리기)에 대해 배울 것이다. 호이스팅은 선언문이 어디에서 선언됐든 속하는 스코프 전체에서 존재하는 것처럼 취급되는 작용을 말한다. 그러나 let을 사용한 선언문은 속하는 스코프에서 호이스팅 효과를 받지 않는다. 따라서 let으로 선언된 변수는 실제 선언문 전에는 명백하게 '존재'하지 않는다.

24. 가비지 콜렉션Garbage Collection  
블록 스코프가 유용한 또 다른 이유는 메모리를 회수하기 위한 클로저 그리고 가비지 콜렉션과 관련 있다.

25. 
function process(data) {
    // do something interesting
}
var someReallyBigData = {...};
process(someReallyBigData);
var btn = document.getElementById("my_button");
btn.addEventListener("click", function click(evt){
    console.log("button clicked");
}, /*capturingPhrase=*/false);
클릭을 처리하는 click 함수는 someReallyBigData 변수가 전혀 필요 없다. 따라서 이론적으로는 process()가 실행된 후 많은 메모리를 먹는 자료 구조인 someReallyBigData는 수거할 수도 있다. 그러나 (어떻게 구현됐는지에 따라 다를 수 있지만) 자바스크립트 엔진은 그 데이터를 여전히 남겨둘 것이다. click 함수가 해당 스코프 전체의 클로저를 가지고 있기 때문이다.

26. 명시적으로 블록을 선언하여 변수의 영역을 한정하는 것은 효과적인 코딩 방식이므로 익혀두면 좋다.

27. 정리하기  
자바스크립트에서 함수는 스코프를 이루는 가장 흔한 단위다. 다른 함수 안에서 선언된 변수와 함수는 본질적으로 다른 '스코프'로부터 '숨겨진' 것이다. 이는 좋은 소프트웨어를 위해 적용해야 할 디자인 원칙이다.  
그러나 함수는 결코 유일한 스코프 단위가 아니다. 블록 스코프는 함수만이 아니라 (일반적으로 {}같은)임의의 코드 블록에 변수와 함수가 속하는 개념이다.  
ES3부터 시작해서 try/catch 구조의 catch 부분은 블록 스코프를 가진다. ES6에서는 키워드 let(키워드 var와 비슷하다)이 추가되어 임의의 코드 블록 안에 변수를 선언할 수 있게 되었다. "if() {let a = 2;}"에서 변수 a는 if 문의 {} 블록 스코프에 자신을 붙인다.  
쉽게 착각하지만, 블록 스코프는 var 함수 스코프를 완전히 대체할 수 없다. 두 기능은 공존하며 개발자들은 함수 스코프와 블록 스코프 기술을 같이 사용할 수 있어야 하고 그래야 한다. 상황에 따라 더 읽기 쉽고 유지 보수가 쉬운 코드를 작성하기 위해 두 기술을 적절한 곳에 사용하면 된다.

### 9. 호이스팅
28. 이 과정을 비유적으로 말하면 변수와 함수 선언문은 선언된 위치에서 코드의 꼭대기로 '끌어올려'진다. 이렇게 선언문을 끌어올리는 동작을 '호이스팅Hoisting'이라고 한다. 즉, 달걀(선언문)이 닭(대입문)보다 먼저다.

29. 함수와 변수 선언문은 모두 끌어올려진다. 그러나 (코드에서 여러 개의 '중복'선언을 하면 확인할 수 있는) 미묘한 차이가 있는데, 먼저 함수가 끌어올려지고 다음으로 변수가 올려진다.

30. 정리하기  
"var a = 2;"는 하나의 구문처럼 보이지만, 자바스크립트 엔진은 그렇게 보지 않는다. 엔진은 이를 "var a"와 "a = 2"라는 두 개의 독립된 구문으로 보고, 첫째 구문은 컴파일러 단계에서 처리하고 둘째 구문은 실행 단계에서 처리한다.  
이것이 의미하는 바는 스코프의 모든 선언문은 어디서 나타나든 실행 전에 먼저 처리된다는 점이다. '호이스팅'이라 불리는 이 과정은 (변수와 함수) 선언문 각각이 속한 스코프의 꼭대기로 '끌어올려'지는 작업이라고 생각할 수 있다. 그 과정에서 선언문 자체는 옮겨지지만, 함수 표현식의 대입문을 포함한 모든 대입문은 끌어올려 지지 않는다.  
중복 선언을 조심하자. 일반 변수 선언과 함수 선언을 섞어 사용하면 특히 더 위험하다!

### 10. 스코프 클로저
31. 클로저는 렉시컬 스코프에 의존해 코드를 작성한 결과로 그냥 발생한다. 이용하려고 굳이 의도적으로 클로저를 생성할 필요도 없다. 모든 코드에서 클로저는 생성되고 사용된다. 그러므로 여기서 적절히 클로저의 전반을 파악하면 클로저를 목적에 따라 확인하고, 받아들이고, 이용할 수 있다.  
깨달음의 순간이 이럴 것이다. "아, 클로저는 내 코드 전반에서 이미 일어나고 있었구나! 이제 난 클로저를 볼 수 있어." 클로저를 이해하는 것은 네오가 매트릭스를 처음 봤을 때와 같을 것이다.

32. 클로저는 함수가 속한 렉시컬 스코프를 기억하여 함수가 렉시컬 스코프 밖에서 실행될 때에도 이 스코프에 접근할 수 있게 하는 기능을 뜻한다.

33. 그럼 클로저의 정체를 완전히 드러낼 코드를 살펴보자.  
function foo() {
    var a = 2;
    function bar() {
        console.log(a);
    }
    return bar;
}
var baz = foo();
baz(); // 2 - Whoa, closure was just observed, man.

34. 일반적으로 foo()가 실행된 후에는 foo()의 내부 스코프가 사라졌다고 생각할 것이다. 이것은 엔진이 가비지 콜렉터Garbage Collector를 고용해 더는 사용하지 않는 메모리를 해제시킨다는 사실을 알기 때문이다. 더는 foo()의 내용을 사용하지 않는 상황이라면 사라졌다고 보는 게 자연스럽다.  
그러나 클로저의 '마법'이 이를 내버려두지 않는다. 사실 foo의 내부 스코프는 여전히 '사용 중'이므로 해제되지 않는다. 그럼 누가 그 스코프를 사용 중인가? 바로 bar()자신이다. 선언된 위치 덕에 bar()는 foo() 스코프에 대한 렉시컬 스코프 클로저를 가지고, foo()는 bar()가 나중에 참조할 수 있도록 스코프를 살려둔다. 즉, bar()는 여전히 해당 스코프에 대한 참조를 가지는데, 그 참조를 바로 클로저라고 부른다.  
foo() 선언이 끝나고 수 밀리 초 후 변수 baz를 호출(bar라 명명했던 내부 함수를 호출)할 때, 해당 함수는 원래 코드의 렉시컬 스코프에 접근할 수 있고 예상한 것처럼 이는 함수가 변수 a에 접근할 수 있다는 의미다.  
함수는 원래 코드의 렉시컬 스코프에서 완전히 벗어나 호출됐다. 클로저는 호출된 함수가 원래 선언된 렉시컬 스코프에 계속해서 접근할 수 있도록 허용한다. 물론, 어떤 방식이든 함수를 값으로 넘겨 다른 위치에서 호출하는 행위는 모두 클로저가 작용한 예다.

35. 어떤 방식으로 내부 함수를 자신이 속한 렉시컬 스코프 밖으로 수송하든 함수는 처음 선언된 곳의 스코프에 대한 참조를 유지한다. 즉, 어디에서 해당 함수를 실행하든 클로저가 작용한다.

36. 이 모듈 패턴을 사용하려면 두 가지 조건이 있다.  
1) 하나의 최외곽 함수가 존재하고, 이 함수가 최소 한 번은 호출되어야 한다(호출할 때마다 새로운 모듈 인스턴스가 생성된다).
2) 최외곽 함수는 최소 한 번은 하나의 내부 함수를 반환해야 한다. 그래야 해당 내부 함수가 비공개 스코프에 대한 클로저를 가져 비공개 상태에 접근하고 수정할 수 있다.  

하나의 함수 속성만을 가지는 객체는 진정한 모듈이 아니다. 함수 실행 결과로 반환된 객체에 데이터 속성들은 있지만 닫힌 함수가 없다면, 당연히 그 객체는 진정한 모듈이 아니다.

37. 정리하기  
편견에 찬 이들은 클로저를 자바스크립트의 세계에서 홀로 떨어진, 가장 용감한 소수만이 닿을 수 있는 신비의 세계로 생각하는 것 같다. 그러나 클로저는 사실 표준이고, 함수를 값으로 마음대로 넘길 수 있는 렉시컬 스코프 환경에서 코드를 작성하는 방법이다.  
클로저는 함수를 렉시컬 스코프 밖에서 호출해도 함수는 자신의 렉시컬 스코프를 기억하고 접근할 수 있는 특성을 의미한다.  
반복문을 예로 들면, 클로저를 통해 설사 우리가 기억하지 못했을지라도 반복문이 어떻게 작동하는지 추적해갈 수 있다. 또한, 클로저는 다양한 형태의 모듈 패턴을 가능하게 하는 매우 효과적인 도구이기도 하다.  
모듈은 두 가지 특징을 가져야 한다.  
1) 최외곽 래퍼 함수를 호출하여 외곽 스코프를 생성한다.  
2) 래핑 함수의 반환 값은 반드시 하나 이상의 내부 함수 참조를 가져야 하고, 그 내부 함수는 래퍼의 비공개 내부 스코프에 대한 클로저를 가져야 한다.  

이제 우리에게는 모든 코드에서 클로저를 볼 수 있고, 파악하고 활용할 수 있는 능력이 생겼다.

### Appendix A. 다양한 환경의 자바스크립트
38. 또한, 한 스크립트에서 에러가 나면(인라인/외부 로딩 둘 다), 독립적인 개발 자바스크립트로 해당 프로그램만 실패 후 중단되며, 다른 후속 스크립트는 아무런 영향을 받지 않고 (여전히 전역 객체를 공유한 상태로) 실행된다.

### Appendix B. 스코프와 렉시컬 this
39. 정확하게 말하면 자바스크립트는 동적 스코프를 사용하지 않고 렉시컬 스코프만 사용한다. 단, this 메커니즘이 동적 스코프와 비슷한 면이 있다.  
주요 차이점은 다음과 같다.  
- 렉시컬 스코프는 작성할 때, 동적 스코프(그리고 this!)는 런타임에 결정된다.  
- 렉시컬 스코프는 어디서 함수가 선언됐는지와 관련 있지만, 동적 스코프는 어디서 함수가 호출됐는지와 관련 있다.  

this는 함수가 어디서 호출됐는지와 관련 있는데, 이점은 this 메커니즘이 동적 스코핑 개념과 상당한 연관이 있다는 것을 보여준다.

40. Arrow function은 this를 Dynamic Scope 에서 Lexical Scope로 fix한다.

41. 사람들은 장황하게 쓰는 걸 싫어한다. 특히 반복적으로 써야 할 때 더욱 그렇다. ES6는 이런 짜증을 덜어주고 이 같은 문제를 고치기 위해 고안됐다. ES6의 해법인 화살표 함수는 '렉시컬 this'라고 부르는 개념을 도입했다.

42. 간단하게 설명하면, 화살표 함수는 this 바인딩과 연계될 때는 일반 함수처럼 작동하지 않는다. 화살표 함수는 모든 this 바인딩에 대한 일반 규칙을 폐기하고, 대신 자신 가까이의 둘러싼 렉시컬 스코프에서 this값을 받아온다. 그래서 앞의 코드에서 화살표 함수는 예상치 못하게 this 바인딩이 해제되는 일 없이 cool() 함수의 this 바인딩을 승계한다.

43. 코드를 짧게 쓰는 용도도 있지만, 내가 볼 때 화살표 함수는 그저 'this 바인딩' 규칙과 '렉시컬 스코프' 규칙을 착각하고 혼합해 쓰는 개발자들의 흔한 실수를 성문화하여 언어의 문법으로 받아들인 것뿐이다.

44. 왜 굳이 this 스타일 코딩 패러다임을 고집해서 그 어려움과 장황함을 겪어야 하는가, 결국 굴복하고 렉시컬 참조와 혼합할 거라면 말이다. 코드를 작성할 때 특정한 접근법을 받아들이는 것은 자연스러운 일이지만, 같은 코드에 여러 접근법을 섞는 것은 그렇지 않다. 내가 생각할 때 이 문제를 해결하는 더 적절한 방식은 this 메커니즘을 정확하게 받아들여 사용하는 것이다.

45. 화살표 함수의 새로운 동작인 렉시컬 this를 선호하든, 이미 증명된 bind()함수를 선호하든 화살표 함수가 단순히 'function'의 줄임말이 아니다. 키워드 function과 화살표 함수의 작용 방식에는 차이가 있따. 이 차이점을 배우고 이해해야 필요할 때 활용할 수 있다.  
이제 우리는 오나전히 렉시컬 스코핑(과 클로저!)를 배웠다. 렉시컬 this를 이해하기는 어렵지 않았을 것이다!
