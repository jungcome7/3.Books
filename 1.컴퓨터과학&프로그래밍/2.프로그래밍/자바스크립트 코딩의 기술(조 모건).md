# 자바스크립트 코딩의 기술
### 지은이 : 조 모건
### 출판사 : 길벗
### 읽은 날 : 2020.02.05 ~ 2020.02.08(1회), 2020.03.07(2회)

# 목차
### 1장. 변수 할당으로 의도를 표현하라
1. const로 변하지 않는 값을 표현하라
2. let과 const로 유효 범위 충돌을 줄여라
3. 블록 유효 범위 변수로 정보를 격리하라
4. 템플릿 리터럴로 변수를 읽을 수 있는 문자열로 변환하라

### 2장. 배열로 데이터 컬렉션을 관리하라
5. 배열로 유연한 컬렉션을 생성하라
6. Includes()로 존재 여부를 확인하라
7. 펼침 연산자로 배열을 본떠라
8. push() 메서드 대신 펼침 연산자로 원본 변경을 피하라
9. 펼침 연산자로 정렬에 의한 혼란을 피하라

### 3장. 특수한 컬렉션을 이용해 코드 명료성을 극대화하라
10. 객체를 이용해 정적인 키-값을 탐색하라
11. Object.assign()으로 조작없이 객체를 생성하라
12. 객체 펼침 연산자로 정보를 갱신하라
13. 맵으로 명확하게 키-값 데이터를 갱신하라
14. 맵과 펼침 연산자로 키-값 데이터를 순회하라
15. 맵 생성 시 부수 효과를 피하라
16. 세트를 이용해 고윳값을 관리하라

### 4장. 조건문을 깔끔하게 작성하라
17. 거짓 값이 있는 조건문을 축약하라
18. 삼항 연산자로 빠르게 데이터를 확인하라
19. 단락 평가를 이용해 효율성을 극대화하라

### 5장. 반복문을 단순하게 만들어라
20. 화살표 함수로 반복문을 단순하게 만들어라
21. 배열 메서드로 반복문을 짧게 작성하라
22. map() 메서드로 비슷한 길이의 배열을 생성하라
23. filter()와 find()로 데이터의 부분집합을 생성하라
24. forEach()로 동일한 동작을 적용하라
25. 체이닝으로 메서드를 연결하라
26. reduce()로 배열 데이터를 변환하라
27. for…in 문과 for…of 문으로 반복문을 정리하라

### 6장. 매개변수와 return 문을 정리하라
28. 매개변수 기본값을 생성하라
29. 해체 할당으로 객체 속성에 접근하라
30. 키-값 할당을 단순화하라
31. 나머지 매개변수로 여러 개의 인수를 변수로 전달하라

### 7장. 유연한 함수를 만들어라
32. 테스트하기 쉬운 함수를 작성하라
33. 화살표 함수로 복잡도를 낮춰라
34. 부분 적용 함수로 단일 책임 매개변수를 관리하라
35. 커링과 배열 메서드를 조합한 부분 적용 함수를 사용하라
36. 화살표 함수로 문맥 혼동을 피하라

### 8장. 클래스로 인터페이스를 간결하게 유지하라
37. 읽기 쉬운 클래스를 만들어라
38. 상속으로 메서드를 공유하라
39. 클래스로 기존의 프로토타입을 확장하라
40. get과 set으로 인터페이스를 단순하게 만들어라
41. 제너레이터로 이터러블 속성을 생성하라
42. bind()로 문맥 문제를 해결하라

### 9장. 외부 데이터에 접근하라
43. 프라미스를 이용해 비동기적으로 데이터를 가져오라
44. async/await로 함수를 명료하게 생성하라
45. fetch로 간단한 AJAX 호출을 처리하라
46. localStorage로 상태를 장기간 유지하라

### 10장. 컴포넌트 아키텍처를 이용해 관련 파일을 모아라
47. 가져오기와 내보내기로 기능을 분리하라
48. npm으로 커뮤니티 코드를 끌어와라
49. 컴포넌트 아키텍처를 이용해 애플리케이션을 만들어라
50. 빌드 도구를 이용해 컴포넌트를 결합하라
51. CSS 애니메이션을 활용하라

### Chapter.1 ~ Chapter.6

1. 그러나 자바스크립트에서는 재할당할 수 없는 const를 기본으로 선택하면 좋습니다. 값을 할당한다는 것은 단순히 정보를 선언하는 것이 아닙니다. 무엇을 정보로 할지에 대한 신호를 보내는 것이기도 합니다. 값을 할당하고 변경하지 않을 것이라는 점을 표시하면, 미래의 개발자(여러분 자신이 될 수도 있습니다)에게 다음 사실, 즉 코드를 훑어볼 때 해당 변수를 신경 쓰지 않아도 된다고 알려줄 수 있습니다. 처음 보는, 그리고 양도 많은 코드를 읽을 때 읽은 내용의 일부를 잊어버려도 괜찮다면 행복하겠지요? Const 덕분입니다.

2. 실제로 키-값 쌍을 사용해 맵 객체와 배열 간의 데이터를 변환합니다. 그리고 현재 TC39위원회는 Object.entries()를 이용해서 객체를 키-값 쌍 배열로 변환하는 명세를 확정했습니다. 따라서 객체를 빠르게 변환해서 배열에 사용하는 모든 기술을 객체에도 사용할 수 있습니다.

3. splice() 메서드가 for문의 괜찮은 대안처럼 보이겠지만, 조작은 너무나 많은 혼란을 가져오므로 가능하면 피하는 것이 좋습니다. 끝으로 방법이 하나 더 있습니다. 배열에는 slice()라는 메서드가 있습니다. Slice() 메서드는 원본 배열을 변경하지 않고 배열의 일부를 반환합니다.

4. 조작이 항상 골치 아픈 일을 만들어내는 것은 아니지만 잠재적으로 문제가 되는 것은 사실이므로, 가능하면 조작을 피하는 것이 좋습니다. 실제로 리덕스를 비롯한 인기 있는 자바스크립트 라이브러리는 조작을 이용하는 함수를 허용하지 않습니다.
또한 모던 자바스크립트의 상당수가 함수형 프로그래밍 형식을 취하기 때문에 부수 효과와 조작이 없는 코드를 작성해야 합니다.

5. 사용해야 할 메서드가 원본을 조작할 때, 어떻게 하면 조작을 막을 수 있을까요? 답은 간단합니다. 원본 데이터를 조작하지 않으면 됩니다. 그 대신에 사본을 만들고, 사본을 조작하세요.
배열을 정렬하기 전에 원본 배열과 펼침 연산자로 새로운 배열을 만들기만 하면 됩니다.

6. ES6는 Object.assign()을 새롭게 추가해 다른 객체의 키-값으로 객체의 필드를 생성하고 갱신할 수 있도록 했습니다. 즉, Object.assign()을 이용하면 다른 객체의 속성을 이용해서 객체를 갱신할 수 있습니다.

7. 중첩된 객체가 있는 객체를 복사하는 것을 깊은 복사(deep copy) 또는 깊은 병합(deep merge)이라고 합니다. 위 예제 코드에서 years 속성은 문제없이 복사할 수 있지만, name 속성은 복사할 수 없습니다. 실제로 키 name에 할당된 독립적인 객체에 대한 참조만 복사됩니다. 중첩된 객체는 해당 객체를 담고 있는 객체와 독립적으로 존재합니다. 중첩된 객체를 담고 있는 객체가 가지고 있는 것은 중첩된 객체에 대한 참조뿐입니다. 참조에 대한 복사만으로는 중첩된 객체에 깊은 복사를 적용할 수 없습니다. 단지 참조의 위치를 복사하는 것에 불과합니다.

8. Object.assign()에서 경험했던 깊은 병합 문제는 객체 펼침 연산자를 사용해도 여전히 발생합니다. 중첩된 객체가 있는 경우에는 객체를 복사하지 않고 참조만 복사하기 때문에 조작으로 인한 잠재적인 문제를 만듭니다.

9. 객체 펼침 연산자는 환상적입니다. 코드를 작성하는 훌륭한 문법인 동시에 여러분의 코드베이스에서 실험적인 기능을 통합할 수 있는 기회도 됩니다.

10. 맵은 특정 작업을 매우 쉽게 처리하는 특별한 종류의 컬렉션입니다. MDN에는 일반적인 객체보다 맵을 컬렉션으로 선택하는 것이 더 나은 상황이 잘 정리되어 있습니다. 전체 목록을 살펴보는 것을 추천합니다. 이번 팁에서는 그중 다음 두 가지 상황을 살펴보겠습니다.
- 키-값 쌍이 자주 추가되거나 삭제되는 경우
- 키가 문자열이 아닌 경우

11. 맵은 좀 더 특화된 컬렉션이므로 자바스크립트 엔진 개발자들은 코드가 좀 더 빠르게 동작하도록 최적화할 수 있습니다. 객체에서 키 탐색은 선형 시간이 소요됩니다. 반면에 맵이 브라우저에 내장 구현된 경우 맵의 키 탐색은 로그 시간이 될 수 있습니다. 즉, 큰 객체가 큰 맵보다 비용이 더 큽니다.

12. 리액트 같은 몇몇 프로젝트에서 단순히 성능 개선을 목적으로 객체 대신 브라우저에 내장된 맵으로 전환한 사례도 있습니다. 객체와 맵을 두고 성능을 가늠할 필요는 없지만, 브라우저 엔진에서 둘을 서로 다르게 다룬다는 점을 기억하길 바랍니다.

13. 객채의 경우 키에 사용할 수 있는 자료형에 제약이 있습니다. 객체에는 특정한 자료형의 키만 사용할 수 있습니다. 가장 중요한 점은 정수를 키로 사용할 수 없다는 것입니다. 이는 수와 관련된 키를 저장할 때 문제가 될 수 있습니다.

14. 정수를 키로 하는 경우는 점 표기법으로 접근할 수 없습니다. Errors[100]처럼 배열 표기법으로 정보에 접근할 수는 있지만, 다소 꼼수에 가깝습니다. 정보에 접근할 수 있는 이유는 오류 코드 객체를 생성했을 때 모든 정수가 문자열로 변환됐기 때문입니다. 그리고 배열 표기법을 사용하면 탐색에 앞서 정수가 문자열로 변경됩니다. 키 목록을 확인해보면 문자열이 담긴 배열이 반환됩니다.

15. 삼항 연산자는 코드를 단순화할 수 있어서 사용할 만한 가치가 있는 경우에만 쓰고, 삼항 연산자로 인해 지나치게 코드가 모호해진다면 일반적인 if문으로 돌아가는 것이 바람직합니다.

16. 불 표현식 true 또는 false를 검사할 때 참 값을 사용할 수 있으므로, 언어 입장에서는 참 값을 구태여 true로 변경ㅎ아는 것이 별 이득이 없습니다. 따라서 OR연산자로 검사한 값 중 하나가 true를 반환하면, 실제로는 true 대신 검사를 통과한 참 값이 반환됩니다.

17. 단순함은 훌륭합니다. 또한, 코드를 한 줄로 줄이는 똑똑한 방법을 찾는 것은 즐거운 일입니다. 그렇지만 목표는 항상 코드를 통한 의사소통과 가독성입니다. 단락 평가를 사용해 코드를 좀 더 읽기 좋게 만드세요. 그저 코드를 줄이기 위한 용도는 아닙니다.

18. for문과 for..of 문을 절대 사용하지 말라는 말이 아닙니다. 그렇지만 적게 사용하는 것이 좋습니다. 왜 그럴까요? 이유는 간단합니다. for문과 for…of문이 불필요할 정도로 어수선하기 때문입니다. 모던 자바스크립트를 작성한다는 것은 간결함, 가독성, 예측 가능성을 갖춘 코드를 작성하는 것을 의미하며, 이러한 목표에 전통적인 반복문은 부합하지 않습니다. 이러한 목표에 적합한 도구는 배열 메서드입니다.

19. find() 메서드를 사용할 때의 유일한 단점은 반환값을 확신할 수 없다는 점입니다.

20. forEach()가 가치 있는 이유는 다른 메서드처럼 코드를 단순하게 만들기 때문이 아닙니다. 그보다는 예측 가능하면서도 다른 배열 메서드와 같이 작동해 함께 연결할 수 있기 때문에 가치가 있는 것입니다.

21. 배열 메서드 체이닝의 유일한 단점은 새로운 메서드를 호출할 때마다 반환된 배열 전체를 다시 반복한다는 점입니다. 모든 작업에 for 문을 사용한다면 name, active, email에 각 한 번씩 총 세 번을 순회하는 것이 전부이지만, 체이닝을 사용하면 모든 작업을 수행하기 위해 일곱 번 반복합니다(원본 배열에 filter()를 적용할 때 세 번, map()에 두 번, forEach()를 호출할 때 두 번). 그렇지만 여기에 지나치게 신경을 쓸 필요는 없습니다. 대규모 데이터를 다루는 것이 아니라면 그리 중요하지 `. 가끔은 약간의 성능 향상보다 가독성이 주용한 경우도 있습니다. 또 때로는 그렇지 않은 경우도 있지요. 그저 반복이 좀 더 많다는 것을 기억해두면 충분합니다.

22. 예를 들어, 인기 있는 에어비엔비의 스타일 가이드는 항상 배열 메서드를 사용하고 for…of 문과 for…in문의 사용을 제한해야 한다고 주장합니다. 그렇지만 모든 사람이 이에 동의하지는 않습니다.

23. 자바스크립트에서는 해체 할당이라는 과정을 통해 객체에 있는 정보를 곧바로 변수에 할당할 수 있습니다. 해체 할당의 작동 원리는 이렇습니다. 먼저 객체에 있는 키와 같은 이름의 변수를 생성하고, 객체에 있는 키에 연결된 값을 생성한 변수의 값으로 할당합니다.

--------------------------------------------------------------------------------------
### 두 번째 읽기

1. 대부분의 경우에는 const를 선택하는 것이 가장 좋습니다. const로 가장 많은 것을 할 수 있기 때문이 아니라 가장 적은 것을 할 수 있기 때문입니다.

2. 그렇지만 var는 어휘적 유효 범위(lexical scope)를 따르는 반면, let은 블록 유효 범위(block scope)를 따릅니다.

3. 부수 효과가 없는 함수를 순수 함수(pure function)라고 하며, 우리는 순수 함수를 만들기 위해 노력해야 합니다.

4. 기존의 배열을 가져다 대괄호에 펼쳐 넣고, 새로운 상품을 배열의 마지막에 추가하면 됩니다. […arr, add] 원본 배열의 내용만 재사용해 새로운 배열을 만드는 것입니다.

5. 사용해야 할 메서드가 원본을 조작할 때, 어떻게 하면 조작을 막을 수 있을까요? 답은 간단합니다. 원본 데이터를 조작하지 않으면 됩니다. 그 대신에 사본을 만들고, 사본을 조작하세요.
배열을 정렬하기 전에 원본 배열과 펼침 연산자로 새로운 배열을 만들기만 하면 됩니다.

6. 핵심은 객체가 정적인 정보에 적합하다는 것입니다. 계속해서 갱신, 반복, 대체, 정렬해야 할 정보에는 적절하지 않습니다. 이때는 맵을 사용하는 것이 낫습니다. 객체는 정보의 경로를 알고 있을 때 적절한 방법입니다.

7. ES6는 Object.assign()을 새롭게 추가해 다른 객체의 키-값으로 객체의 필드를 생성하고 갱신할 수 있도록 했습니다. 즉, Object.assign()을 이용하면 다른 객체의 속성을 이용해서 객체를 갱신할 수 있습니다.

8. 객체 펼침 연산자는 환상적입니다. 코드를 작성하는 훌륭한 문법인 동시에 여러분의 코드베이스에서 실험적인 기능을 통합할 수 있는 기회도 됩니다.

9. MDN에는 일반적인 객체보다 맵을 컬렉션으로 선택하는 것이 더 나은 상황이 잘 정리되어 있습니다. 
- 키-값 쌍이 자주 추가되거나 삭제되는 경우
- 키가 문자열이 아닌 경우

10. 맵은 객체와 다르게 키-값 쌍을 자주 변경하는 경우에 적합하도록 특별히 설계되었습니다. 인터페이스가 명확하고, 메서드는 예측 가능한 이름을 가지고 있으며, 반복과 같은 동작이 내장되어 있습니다. 맵을 사용하면 좀 더 생산성 높은 개발자가 될 수 있습니다. 더 많이 예측할수록 더 빨리 만들 수 있습니다.

11. 객체의 경우 키에 사용할 수 있는 자료형에 제약이 있습니다. 객체에는 특정한 자료형의 키만 사용할 수 있습니다. 가장 중요한 점은 정수를 키로 사용할 수 없다는 것입니다. 이는 수와 관련된 키를 저장할 때 문제가 될 수 있습니다.

12. 삼항 연산자는 코드를 단순화할 수 있어서 사용할 만한 가치가 있는 경우에만 쓰고, 삼항 연산자로 인해 지나치게 코드가 모호해진다면 일반적인 if 문으로 돌아가는 것이 바람직합니다.

13. 단락 평가의 가장 좋은 부분은 표현식의 끝에 기본값을 추가할 수 있다는 것입니다. 따라서 변수가 거짓 값이 될 가능성을 염려하지 않아도 됩니다. 마지막에는 참 값이 기다리고 있으니까요.

14. for 문과 for…of 문이 불필요할 정도로 어수선하기 때문입니다. 모던 자바스크립트를 작성한다는 것은 간결함, 가독성, 예측 가능성을 갖춘 코드를 작성하는 것을 의미하며, 이러한 목표에 전통적인 반복문은 부합하지 않습니다. 이러한 목표에 적합한 도구는 배열 메서드입니다.

15. forEach() 메서드가 있다면 부수 효과가 발생한다는 점을 알 수 있습니다. … 그럼에도 불구하고 forEach()를 사용하는 가장 큰 이유는 체이닝 과정에서 다른 배열 메서드와 결합할 수 있기 때문입니다. 매번 변수에 배열 메서드의 결괏값을 저장할 필요 없이 동일한 배열에서 여러 작업을 처리할 수 있습니다.

16. 배열 메서드 체이닝의 유일한 단점은 새로운 메서드를 호출할 때마다 반환된 배열 전체를 다시 반복한다는 점입니다. 모든 작업에 for 문을 사용한다면 name, active, email에 각 한 번씩 총 세 번을 순회하는 것이 전부이지만, 체이닝을 사용하면 모든 작업을 수행하기 위해 일곱 번 반복합니다(원본 배열에 filter()를 적용할 때 세 번, map()에 두 번, forEach()를 호출할 때 두 번). 그렇지만 여기에 지나치게 신경 쓸 필요는 없습니다. 대규모 데이터를 다루는 것이 아니라면 그리 중요하지 않습니다. 가끔은 약간의 선능 향상보다 가독성이 중요한 경우도 있습니다. 또 때로는 그렇지 않은 경우도 있지요. 그저 반복이 좀 더 많다는 것을 기억해두면 충분합니다.

17. 매개변수 기본값을 사용하려면 매개변수명 옆에 등호로 기본값을 정의합니다. 매개변수에 값을 전달하지 않으면 설정한 기본값이 사용됩니다.

18. 해체 할당의 가장 큰 장점은 해체 할당을 함수의 매개변수에 적용할 수 있다는 점입니다. 해체 할당을 매개변수에 사용하면, 변수를 선언하지 않아도 마치 정보를 함수 몸체에서 할당한 것처럼 작동합니다. 참고로 해체 할당은 let으로 변수를 할당하기 때문에 해당 변수를 재할당할 수도 있습니다.

19. 해체 할당의 유일한 단점은 키-값 쌍 또는 클래스의 인스턴스인 객체에서만 사용할 수 있다는 점입니다. 맵에는 해체 할당을 사용할 수 없습니다. 그렇지만 해체 할당은 함수 간에 정보를 전달하는 경우에 사용되며, 이 경우 값을 순회하거나 재할당하지 않으므로 문제가 될 것이 없습니다. 즉, 데이터가 정적이므로 객체는 훌륭한 선택입니다.

20. 주의할 점은 부모 클래스에 추가하는 모든 메서드를 자식 클래스가 상속받는다는 것입니다. 이는 큰 이점이기도 하지만, 자식 클래스에서 필요하지 않은 메서드를 부모 클래스에 추가하면 자식 클래스가 비대해지기 쉽습니다.

21. new 키워드로 새로운 인스턴스를 생성할 때, 생성자를 실행하고 this 문맥을 바인딩하지만 메서드를 복제하지는 않습니다. 생성자에서 this에 메서드를 추가할 수도 있지만, 프로토타입에 직접 추가하는 것이 훨씬 더 효율적입니다.

22. 프로토타입은 생성자 함수의 기반이 되는 객체입니다. 모든 객체 인스턴스는 프로토타입에서 속성을 가져옵니다. 게다가 새로운 인스턴스도 프로토타입에 있는 메서드를 사용할 수 있습니다.

23. 객체는 직접적으로 순회할 수 없습니다. 객체의 일부를 먼저 배열로 변환해야 합니다.

24. 비동기 언어의 가치는 지연된 정보를 기다리는 동안 이 정보가 필요하지 않은 다른 코드를 실행할 수 있다는 점에 있습니다. API 응답을 기다리는 동안 여전히 다른 요소의 클릭 메서드에 응답하거나 다른 데이터 원본에 있는 값을 계산할 수 있습니다. 지연된 정보를 기다리는 동안 코드가 멈춰버리지 않지요.

25. async/await가 프라미스를 대체하지는 않습니다. 단지 프라미스를 더 나은 문법으로 감싸는 것에 불과합니다.

26. 이제 AJAX 호출을 처리할 수 있는 fetch()라는 훨씬 간단한 도구가 생겼습니다. 이번 팁은 다른 팁들과 조금 다릅니다. Fetch()는 자바스크립트 명세의 일부가 아닙니다. Fetch() 명세는 WHATWG(Web Hypertext Application Technology Working Group)가 정의합니다. 따라서 fetch()는 대부분의 최신 브라우저에서 지원되지만 Node.js에서는 기본적으로 지원되지 않습니다. Node.js에서 fetch()를 사용하려면 node-fetch 패키지를 사용하세요.

27. (모듈, export를 이용해) 함수, 변수, 클래스를 내보낼 수 있습니다. 모든 것을 내보낼 필요는 없으며, 여러 함수 중 일부 함수만 내보내는 경우에는 기본적으로 공개 함수와 비공개 함수를 생성한 것과 같습니다.

28. 개발자 도구가 발전하면서 새로운 패턴이 나타났습니다. 바로 컴포넌트 아키텍처라는 패턴입니다. 컴포넌트는 관련 있는 모든 코드를 조합해 하나의 디렉터리에 담은 것입니다. 이렇게 하면 조각을 하나씩 추가하는 방법으로 웹 페이지나 애플리케이션을 만들 수 있습니다. 페이지에 있는 사이드바의 버튼처럼 말이죠. 이렇게 해서 작동하는 애플리케이션이 될 때까지 컴포넌트를 추가합니다.

29. 웹팩을 이용하면 자바스크립트 병합뿐만 아니라 CSS와 Sass 처리, 이미지 변환도 해결할 수 있습니다. 웹팩에서는 로더(loader)라고 부르는 방법을 이용해 파일 확장자에 따라 필요한 다른 동작을 선언할 수 있습니다. 따라서 다양ㅇ한 파일 형식을 다룰 수 있지요.
